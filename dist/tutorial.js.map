{"version":3,"file":"tutorial.js","mappings":"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","sources":["webpack://jsonFormula/webpack/bootstrap","webpack://jsonFormula/webpack/runtime/make namespace object","webpack://jsonFormula/./src/dataTypes.js","webpack://jsonFormula/./src/tokenDefinitions.js","webpack://jsonFormula/./src/errors.js","webpack://jsonFormula/./src/matchType.js","webpack://jsonFormula/./src/utils.js","webpack://jsonFormula/./src/TreeInterpreter.js","webpack://jsonFormula/./src/Lexer.js","webpack://jsonFormula/./src/Parser.js","webpack://jsonFormula/./src/functions.js","webpack://jsonFormula/./src/interpreter.js","webpack://jsonFormula/./src/json-formula.js","webpack://jsonFormula/./tutorial/Form.js","webpack://jsonFormula/./src/stringToNumber.js","webpack://jsonFormula/./tutorial/tutorial.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n// Type constants used to define functions.\nconst dataTypes = {\n  TYPE_NUMBER: 0,\n  TYPE_ANY: 1,\n  TYPE_STRING: 2,\n  TYPE_ARRAY: 3,\n  TYPE_OBJECT: 4,\n  TYPE_BOOLEAN: 5,\n  TYPE_EXPREF: 6,\n  TYPE_NULL: 7,\n  TYPE_ARRAY_NUMBER: 8,\n  TYPE_ARRAY_STRING: 9,\n  TYPE_ARRAY_ARRAY: 10,\n  TYPE_EMPTY_ARRAY: 11,\n};\n\nconst typeNameTable = {\n  [dataTypes.TYPE_NUMBER]: 'number',\n  [dataTypes.TYPE_ANY]: 'any',\n  [dataTypes.TYPE_STRING]: 'string',\n  [dataTypes.TYPE_ARRAY]: 'array',\n  [dataTypes.TYPE_OBJECT]: 'object',\n  [dataTypes.TYPE_BOOLEAN]: 'boolean',\n  [dataTypes.TYPE_EXPREF]: 'expression',\n  [dataTypes.TYPE_NULL]: 'null',\n  [dataTypes.TYPE_ARRAY_NUMBER]: 'Array<number>',\n  [dataTypes.TYPE_ARRAY_STRING]: 'Array<string>',\n  [dataTypes.TYPE_ARRAY_ARRAY]: 'Array<array>',\n  [dataTypes.TYPE_EMPTY_ARRAY]: 'array',\n};\n\nexport { dataTypes, typeNameTable };\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nexport default {\n  TOK_EOF: 'EOF',\n  TOK_IDENTIFIER: 'Identifier',\n  TOK_QUOTEDIDENTIFIER: 'QuotedIdentifier',\n  TOK_RBRACKET: 'Rbracket',\n  TOK_RPAREN: 'Rparen',\n  TOK_COMMA: 'Comma',\n  TOK_COLON: 'Colon',\n  TOK_CONCATENATE: 'Concatenate',\n  TOK_RBRACE: 'Rbrace',\n  TOK_NUMBER: 'Number',\n  TOK_CURRENT: 'Current',\n  TOK_GLOBAL: 'Global',\n  TOK_EXPREF: 'Expref',\n  TOK_PIPE: 'Pipe',\n  TOK_OR: 'Or',\n  TOK_AND: 'And',\n  TOK_ADD: 'Add',\n  TOK_SUBTRACT: 'Subtract',\n  TOK_UNARY_MINUS: 'UnaryMinus',\n  TOK_MULTIPLY: 'Multiply',\n  TOK_UNION: 'Union',\n  TOK_DIVIDE: 'Divide',\n  TOK_COMPARATOR: 'Comparator',\n  TOK_FLATTEN: 'Flatten',\n  TOK_STAR: 'Star',\n  TOK_FILTER: 'Filter',\n  TOK_DOT: 'Dot',\n  TOK_NOT: 'Not',\n  TOK_LBRACE: 'Lbrace',\n  TOK_LBRACKET: 'Lbracket',\n  TOK_LPAREN: 'Lparen',\n  TOK_JSON: 'Literal',\n  TOK_STRING: 'String',\n  TOK_INT: 'Integer',\n};\n","/*\nCopyright 2023 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nexport function typeError(desc) {\n  return new TypeError(desc);\n}\n\nexport function syntaxError(desc) {\n  const e = new Error(desc);\n  e.name = 'SyntaxError';\n  return e;\n}\n\nexport function functionError(desc) {\n  const e = new Error(desc);\n  e.name = 'FunctionError';\n  return e;\n}\n\nexport function evaluationError(desc) {\n  const e = new Error(desc);\n  e.name = 'EvaluationError';\n  return e;\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport { dataTypes, typeNameTable } from './dataTypes.js';\nimport tokenDefinitions from './tokenDefinitions.js';\nimport { typeError } from './errors.js';\n// import { isClass } from './utils.js';\n\nconst {\n  TYPE_NUMBER,\n  TYPE_ANY,\n  TYPE_STRING,\n  TYPE_ARRAY,\n  TYPE_OBJECT,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n  TYPE_ARRAY_ARRAY,\n  TYPE_EMPTY_ARRAY,\n} = dataTypes;\n\nconst {\n  TOK_EXPREF,\n} = tokenDefinitions;\n\nfunction isArray(t) {\n  return [\n    TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING, TYPE_ARRAY_ARRAY, TYPE_EMPTY_ARRAY,\n  ].includes(t);\n}\n\nexport function getType(inputObj) {\n  if (inputObj === null) return TYPE_NULL;\n  // if inputObj is a class, then convert it to its base type via JSON\n  const obj = JSON.parse(JSON.stringify(inputObj));\n  switch (Object.prototype.toString.call(obj)) {\n    case '[object String]':\n      return TYPE_STRING;\n    case '[object Number]':\n      return TYPE_NUMBER;\n    case '[object Array]':\n      if (obj.length === 0) return TYPE_EMPTY_ARRAY;\n      if (obj.every(a => isArray(getType(a)))) return TYPE_ARRAY_ARRAY;\n      if (obj.every(a => getType(a) === TYPE_NUMBER)) return TYPE_ARRAY_NUMBER;\n      if (obj.every(a => getType(a) === TYPE_STRING)) return TYPE_ARRAY_STRING;\n      return TYPE_ARRAY;\n    case '[object Boolean]':\n      return TYPE_BOOLEAN;\n    case '[object Null]':\n      return TYPE_NULL;\n    default: // '[object Object]':\n      // Check if it's an expref.  If it has, it's been\n      // tagged with a jmespathType attr of 'Expref';\n      if (obj.jmespathType === TOK_EXPREF) {\n        return TYPE_EXPREF;\n      }\n      return TYPE_OBJECT;\n  }\n}\n\nexport function isArrayType(t) {\n  return [\n    TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING, TYPE_ARRAY_ARRAY, TYPE_EMPTY_ARRAY,\n  ].includes(getType(t));\n}\n\nexport function getTypeName(arg) {\n  return typeNameTable[getType(arg)];\n}\n\nexport function matchType(expectedList, argValue, context, toNumber, toString) {\n  const actual = getType(argValue);\n  if (argValue?.jmespathType === TOK_EXPREF && !expectedList.includes(TYPE_EXPREF)) {\n    throw typeError(`${context} does not accept an expression reference argument.`);\n  }\n  const isObject = t => t === TYPE_OBJECT;\n  const match = (expect, found) => expect === found\n    || expect === TYPE_ANY\n    || (expect === TYPE_ARRAY && isArray(found))\n    || (isArray(expect) && found === TYPE_EMPTY_ARRAY);\n\n  if (expectedList.some(type => match(type, actual))) return argValue;\n\n  // if the function allows multiple types, we can't coerce the type and we need an exact match\n  const exactMatch = expectedList.length > 1;\n  const expected = expectedList[0];\n  let wrongType = false;\n\n  // Can't coerce objects and arrays to any other type\n  if (isArray(actual)) {\n    if ([TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING].includes(expected)) {\n      if (argValue.some(a => {\n        const t = getType(a);\n        // can't coerce arrays or objects to numbers or strings\n        return isArray(t) || isObject(t);\n      })) wrongType = true;\n    }\n  }\n  // nothing coerces to an object\n  if (exactMatch && expected === TYPE_OBJECT) wrongType = true;\n\n  if (exactMatch) {\n    throw typeError(`${context} cannot process type: ${typeNameTable[actual]}. Must be one of: ${expectedList.map(t => typeNameTable[t]).join(', ')}.`);\n  }\n  if (wrongType) {\n    throw typeError(`${context} expected argument to be type ${typeNameTable[expected]} but received type ${typeNameTable[actual]} instead.`);\n  }\n  // Can't coerce Objects and arrays to anything other than boolean\n  if (isObject(actual) && expected === TYPE_BOOLEAN) {\n    return Object.keys(argValue).length === 0;\n  }\n  // no exact match, see if we can coerce an array type\n  if (isArray(actual)) {\n    const toArray = a => (Array.isArray(a) ? a : [a]);\n    if (expected === TYPE_BOOLEAN) return argValue.length > 0;\n    if (expected === TYPE_ARRAY_STRING) return argValue.map(toString);\n    if (expected === TYPE_ARRAY_NUMBER) return argValue.map(toNumber);\n    if (expected === TYPE_ARRAY_ARRAY) return argValue.map(toArray);\n  }\n\n  if (!isArray(actual) && !isObject(actual)) {\n    if (expected === TYPE_ARRAY_STRING) return actual === TYPE_NULL ? [] : [toString(argValue)];\n    if (expected === TYPE_ARRAY_NUMBER) return actual === TYPE_NULL ? [] : [toNumber(argValue)];\n    if (expected === TYPE_ARRAY) return actual === TYPE_NULL ? [] : [argValue];\n    if ([TYPE_ARRAY_ARRAY, TYPE_EMPTY_ARRAY].includes(expected) && actual === TYPE_NULL) return [];\n    if (expected === TYPE_NUMBER) return toNumber(argValue);\n    if (expected === TYPE_STRING) return toString(argValue);\n    if (expected === TYPE_BOOLEAN) return !!argValue;\n    if (expected === TYPE_OBJECT && actual === TYPE_NULL) return {};\n  }\n\n  throw typeError(`${context} expected argument to be type ${typeNameTable[expected]} but received type ${typeNameTable[actual]} instead.`);\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nexport function isArray(obj) {\n  return Array.isArray(obj);\n}\n\nexport function isObject(obj) {\n  if (obj !== null) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  }\n  return false;\n}\n\nexport function getValueOf(a) {\n  if (a === null || a === undefined) return a;\n  if (isArray(a)) {\n    return a.map(i => getValueOf(i));\n  }\n  // if we have a child named 'valueOf' then we're an object,\n  // and just return the object.\n  if (typeof (a.valueOf) !== 'function') return a;\n  return a.valueOf();\n}\n\nexport function toBoolean(param) {\n  if (param === null) return false;\n  // in case it's an object with a valueOf defined\n  const val = getValueOf(param);\n\n  // empty arrays are false\n  if (Array.isArray(val)) return val.length > 0;\n  // empty objects are false\n  if (isObject(val)) return Object.keys(val).length > 0;\n  return !!val;\n}\n\nexport function strictDeepEqual(lhs, rhs) {\n  const first = getValueOf(lhs);\n  const second = getValueOf(rhs);\n  // Check the scalar case first.\n  if (first === second) {\n    return true;\n  }\n\n  // Check if they are the same type.\n  const firstType = Object.prototype.toString.call(first);\n  if (firstType !== Object.prototype.toString.call(second)) {\n    return false;\n  }\n  // We know that first and second have the same type so we can just check the\n  // first type from now on.\n  if (isArray(first) === true) {\n    // Short circuit if they're not the same length;\n    if (first.length !== second.length) return false;\n    return first.every((f, i) => strictDeepEqual(f, second[i]));\n  }\n  if (isObject(first) === true) {\n    if (Object.keys(first).length !== Object.keys(second).length) return false;\n    // An object is equal if it has the same key/value pairs.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in first) {\n      if (hasOwnProperty.call(first, key)) {\n        if (strictDeepEqual(first[key], second[key]) === false) return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function getProperty(obj, key) {\n  const desc = Object.getOwnPropertyDescriptor(obj, key);\n  // if it's a regular enumerable property or if it's configured with a getter,\n  // then return it.\n  // if it's a built-in property such as length or toString etc. we'll want to ignore it.\n  if (desc?.enumerable || !!desc?.get) {\n    // for applications that want to track which properties are accessed, allow for a special\n    // hook to callback and register this key/value accessor.\n    obj[key]?.[Symbol.for('track')]?.(obj, key);\n    return obj[key];\n  }\n  return undefined;\n}\n\nexport function debugAvailable(debug, obj, key) {\n  try {\n    debug.push(`Failed to find: '${key}'`);\n    let available = [];\n    if (isArray(obj) && obj.length > 0) {\n      available.push(`${0}..${obj.length - 1}`);\n    }\n    if (obj !== null) {\n      available = [...available, ...Object.entries(Object.getOwnPropertyDescriptors(obj, key))\n        .filter(([k, desc]) => (desc?.enumerable || !!desc?.get) && !/^[0-9]+$/.test(k) && (!k.startsWith('$') || key.startsWith('$')))\n        .map(([k]) => `'${k}'`)];\n    }\n    if (available.length) debug.push(`Available fields: ${available}`);\n  // eslint-disable-next-line no-empty\n  } catch (e) {}\n}\n\nexport function isClass(obj) {\n  if (obj === null) return false;\n  if (Array.isArray(obj)) return false;\n  return !['Object', 'Boolean', 'Number', 'String'].includes(obj.constructor.name);\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport {\n  matchType, getTypeName, getType, isArrayType,\n} from './matchType.js';\nimport { dataTypes } from './dataTypes.js';\nimport tokenDefinitions from './tokenDefinitions.js';\nimport {\n  isArray, isObject, strictDeepEqual, getValueOf, getProperty, debugAvailable, toBoolean,\n} from './utils.js';\nimport { evaluationError, typeError } from './errors.js';\n\nconst {\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_FLATTEN,\n} = tokenDefinitions;\n\nconst {\n  TYPE_STRING,\n  TYPE_ARRAY_STRING,\n  TYPE_ARRAY,\n  TYPE_NUMBER,\n} = dataTypes;\n\nfunction objValues(obj) {\n  return Object.values(obj);\n}\n\nfunction balanceArrayOperands(opLeft, opRight) {\n  if (isArray(opLeft) && isArray(opRight)) {\n    // balance the size of the arrays by padding with nulls\n    const shorter = opLeft.length < opRight.length ? opLeft : opRight;\n    const diff = Math.abs(opLeft.length - opRight.length);\n    shorter.length += diff;\n    shorter.fill(null, shorter.length - diff);\n  }\n}\n\nexport default class TreeInterpreter {\n  constructor(runtime, globals, toNumber, toString, debug, language) {\n    this.runtime = runtime;\n    this.globals = globals;\n    this.toNumber = toNumber;\n    this.toString = toString;\n    this.debug = debug;\n    this.language = language;\n  }\n\n  search(node, value) {\n    return this.visit(node, value);\n  }\n\n  field(node, value) {\n    // we used to check isObject(value) here -- but it is possible for an array-based\n    // object to have properties.  So we'll allow the child check on objects and arrays.\n    if (value !== null && (isObject(value) || isArray(value))) {\n      const field = getProperty(value, node.name);\n      if (field === undefined) {\n        debugAvailable(this.debug, value, node.name);\n        return null;\n      }\n      return field;\n    }\n    debugAvailable(this.debug, value, node.name);\n    return null;\n  }\n\n  visit(n, v) {\n    const visitFunctions = {\n      Identifier: this.field.bind(this),\n      QuotedIdentifier: this.field.bind(this),\n\n      ChainedExpression: (node, value) => {\n        let result = this.visit(node.children[0], value);\n        for (let i = 1; i < node.children.length; i += 1) {\n          result = this.visit(node.children[1], result);\n          if (result === null) return null;\n        }\n        return result;\n      },\n\n      BracketExpression: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      Index: (node, value) => {\n        if (isArray(value)) {\n          let index = node.value.value;\n          if (index < 0) {\n            index = value.length + index;\n          }\n          const result = value[index];\n          if (result === undefined) {\n            this.debug.push(`Index: ${index} out of range for array size: ${value.length}`);\n            return null;\n          }\n          return result;\n        }\n        this.debug.push('Left side of index expression must be an array');\n        this.debug.push(`Did you intend a single-element array? if so, use a JSON literal: \\`[${node.value.value}]\\``);\n        return null;\n      },\n\n      Slice: (node, value) => {\n        if (!isArray(value)) {\n          this.debug.push('Slices apply to arrays only');\n          return null;\n        }\n        const sliceParams = node.children.map(param => (param === null ? null : param.value));\n        const [start, stop, step] = this.computeSliceParams(value.length, sliceParams);\n        const result = [];\n        if (step > 0) {\n          for (let i = start; i < stop; i += step) {\n            result.push(value[i]);\n          }\n        } else {\n          for (let i = start; i > stop; i += step) {\n            result.push(value[i]);\n          }\n        }\n        return result;\n      },\n\n      Projection: (node, value) => {\n      // Evaluate left child.\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) {\n          if (node.debug === 'Wildcard') {\n            this.debug.push('Bracketed wildcards apply to arrays only');\n          }\n          return null;\n        }\n        const collected = [];\n        base.forEach(b => {\n          const current = this.visit(node.children[1], b);\n          collected.push(current);\n        });\n        return collected;\n      },\n\n      // wildcard: \".*\"\n      ValueProjection: (node, value) => {\n      // Evaluate left child.\n        const projection = this.visit(node.children[0], value);\n        if (!isObject(getValueOf(projection))) {\n          this.debug.push('Chained wildcards apply to objects only');\n          return null;\n        }\n        const collected = [];\n        const values = objValues(projection);\n        values.forEach(val => {\n          const current = this.visit(node.children[1], val);\n          collected.push(current);\n        });\n        return collected;\n      },\n\n      FilterProjection: (node, value) => {\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) {\n          this.debug.push('Filter expressions apply to arrays only');\n          return null;\n        }\n        const filtered = base.filter(b => {\n          const matched = this.visit(node.children[2], b);\n          return toBoolean(matched);\n        });\n\n        const finalResults = [];\n        filtered.forEach(f => {\n          const current = this.visit(node.children[1], f);\n          finalResults.push(current);\n        });\n        return finalResults;\n      },\n\n      Comparator: (node, value) => {\n        let first = getValueOf(this.visit(node.children[0], value));\n        let second = getValueOf(this.visit(node.children[1], value));\n\n        if (node.value === '==') return strictDeepEqual(first, second);\n        if (node.value === '!=') return !strictDeepEqual(first, second);\n        if (isObject(first) || isArray(first)) {\n          this.debug.push(`Cannot use comparators with ${getTypeName(first)}`);\n          return false;\n        }\n        if (isObject(second) || isArray(second)) {\n          this.debug.push(`Cannot use comparators with ${getTypeName(second)}`);\n          return false;\n        }\n        const type1 = getType(first);\n        const type2 = getType(second);\n        // if either parameter is a number, we need to do a numeric comparison\n        // javascript will compare this way automatically, but if we explicitly convert\n        // to numbers, we will get debug warnings for non-numeric strings\n        if (type1 === TYPE_NUMBER || type2 === TYPE_NUMBER) {\n          // if toNumber fails, it will populate the debug array\n          // with an appropriate warning\n          try {\n            first = this.toNumber(first);\n            second = this.toNumber(second);\n            if (first === null || second === null) return false;\n          } catch (_e) {\n            // failing to convert to a number for comparison is not an error\n            // we just return false\n            return false;\n          }\n        }\n        if (node.value === '>') return first > second;\n        if (node.value === '>=') return first >= second;\n        if (node.value === '<') return first < second;\n        // if (node.value === '<=)\n        // must be LTE\n        return first <= second;\n      },\n\n      [TOK_FLATTEN]: (node, value) => {\n        const original = this.visit(node.children[0], value);\n        if (!isArray(original)) {\n          this.debug.push('Flatten expressions apply to arrays only. If you want an empty array, use a JSON literal: `[]`');\n          return null;\n        }\n        const merged = [];\n        original.forEach(current => {\n          if (isArray(current)) {\n            merged.push(...current);\n          } else {\n            merged.push(current);\n          }\n        });\n        return merged;\n      },\n\n      Identity: (_node, value) => value,\n\n      ArrayExpression: (node, value) => node.children.map(child => this.visit(child, value)),\n\n      ObjectExpression: (node, value) => {\n        // at one time we used to have this:\n        // if (value === null) return null;\n        // BUT then an expression such as:\n        // values({a: 'aa'})\n        // would return null if the document were `null`\n        // Removing the check means that:\n        // `null`.{a: 'aa'}\n        // returns: {a: 'aa'}\n        // which is a bit odd, but seems correct.\n        const collected = {};\n        node.children.forEach(child => {\n          if (collected[child.name] !== undefined) this.debug.push(`Duplicate key: '${child.name}'`);\n          collected[child.name] = this.visit(child.value, value);\n        });\n        return collected;\n      },\n\n      OrExpression: (node, value) => {\n        let matched = this.visit(node.children[0], value);\n        if (!toBoolean(matched)) matched = this.visit(node.children[1], value);\n        return matched;\n      },\n\n      AndExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n\n        if (!toBoolean(first)) return first;\n        return this.visit(node.children[1], value);\n      },\n\n      AddExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        balanceArrayOperands(first, second);\n        return this.applyOperator(first, second, '+');\n      },\n\n      ConcatenateExpression: (node, value) => {\n        let first = this.visit(node.children[0], value);\n        let second = this.visit(node.children[1], value);\n        balanceArrayOperands(first, second);\n        if (isArrayType(first)) {\n          first = matchType([TYPE_ARRAY_STRING], first, 'concatenate', this.toNumber, this.toString);\n        } else {\n          first = matchType([TYPE_STRING], first, 'concatenate', this.toNumber, this.toString);\n        }\n        if (isArrayType(second)) {\n          second = matchType([TYPE_ARRAY_STRING], second, 'concatenate', this.toNumber, this.toString);\n        } else {\n          second = matchType([TYPE_STRING], second, 'concatenate', this.toNumber, this.toString);\n        }\n        return this.applyOperator(first, second, '&');\n      },\n\n      UnionExpression: (node, value) => {\n        let first = this.visit(node.children[0], value);\n        let second = this.visit(node.children[1], value);\n        first = matchType([TYPE_ARRAY], first, 'union', this.toNumber, this.toString);\n        second = matchType([TYPE_ARRAY], second, 'union', this.toNumber, this.toString);\n        return first.concat(second);\n      },\n\n      SubtractExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        balanceArrayOperands(first, second);\n        return this.applyOperator(first, second, '-');\n      },\n\n      MultiplyExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        balanceArrayOperands(first, second);\n        return this.applyOperator(first, second, '*');\n      },\n\n      DivideExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        balanceArrayOperands(first, second);\n        return this.applyOperator(first, second, '/');\n      },\n\n      NotExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return !toBoolean(first);\n      },\n\n      UnaryMinusExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const minus = first * -1;\n        if (Number.isNaN(minus)) throw typeError(`Failed to convert \"${first}\" to number`);\n        return minus;\n      },\n\n      String: node => node.value,\n\n      Literal: node => node.value,\n\n      Number: node => node.value,\n\n      Integer: node => node.value,\n\n      [TOK_PIPE]: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      [TOK_CURRENT]: (_node, value) => value,\n\n      [TOK_GLOBAL]: node => {\n        const result = this.globals[node.name];\n        return result === undefined ? null : result;\n      },\n\n      Function: (node, value) => {\n      // Special case for if()\n      // we need to make sure the results are called only after the condition is evaluated\n      // Otherwise we end up with both results invoked -- which could include side effects\n      // For \"if\", the last parameter to callFunction is false (bResolved) to indicate there's\n      // no point in validating the argument type.\n        if (node.name === 'if') return this.runtime.callFunction(node.name, node.children, value, this, false);\n        const resolvedArgs = node.children.map(child => this.visit(child, value));\n        return this.runtime.callFunction(node.name, resolvedArgs, value, this);\n      },\n\n      ExpressionReference: node => {\n        const [refNode] = node.children;\n        // Tag the node with a specific attribute so the type\n        // checker verify the type.\n        refNode.jmespathType = TOK_EXPREF;\n        return refNode;\n      },\n    };\n    const fn = n && visitFunctions[n.type];\n    return fn(n, v);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  computeSliceParams(arrayLength, sliceParams) {\n    function capSliceRange(arrayLen, actual, stp) {\n      let actualValue = actual;\n      if (actualValue < 0) {\n        actualValue += arrayLen;\n        if (actualValue < 0) {\n          actualValue = stp < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLen) {\n        actualValue = stp < 0 ? arrayLen - 1 : arrayLen;\n      }\n      return actualValue;\n    }\n\n    let [start, stop, step] = sliceParams;\n    if (step === null) {\n      step = 1;\n    } else if (step === 0) {\n      throw evaluationError('Invalid slice, step cannot be 0');\n    }\n    const stepValueNegative = step < 0;\n\n    if (start === null) {\n      start = stepValueNegative ? arrayLength - 1 : 0;\n    } else {\n      start = capSliceRange(arrayLength, start, step);\n    }\n\n    if (stop === null) {\n      stop = stepValueNegative ? -1 : arrayLength;\n    } else {\n      stop = capSliceRange(arrayLength, stop, step);\n    }\n    return [start, stop, step];\n  }\n\n  applyOperator(first, second, operator) {\n    if (isArray(first) && isArray(second)) {\n      const result = [];\n      for (let i = 0; i < first.length; i += 1) {\n        result.push(this.applyOperator(first[i], second[i], operator));\n      }\n      return result;\n    }\n\n    if (isArray(first)) return first.map(a => this.applyOperator(a, second, operator));\n    if (isArray(second)) return second.map(a => this.applyOperator(first, a, operator));\n\n    if (operator === '&') return first + second;\n    if (operator === '*') return this.toNumber(first) * this.toNumber(second);\n    const n1 = this.toNumber(first);\n    const n2 = this.toNumber(second);\n    if (operator === '+') return n1 + n2;\n    if (operator === '-') return n1 - n2;\n    // if (operator === '/') {\n    // Must be division\n    const result = n1 / n2;\n    if (!Number.isFinite(result)) {\n      throw evaluationError(`Division by zero ${first}/${second}`);\n    }\n    return result;\n  }\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\nimport tokenDefinitions from './tokenDefinitions.js';\nimport { syntaxError } from './errors.js';\n\nconst {\n  TOK_IDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_COLON,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_COMPARATOR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_UNARY_MINUS,\n  TOK_DIVIDE,\n  TOK_UNION,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n  TOK_JSON,\n  TOK_STRING,\n  TOK_INT,\n} = tokenDefinitions;\n\n// The \"&\", \"[\", \"<\", \">\" tokens\n// are not in basicToken because\n// there are two token variants\n// (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n// below.\n\nconst basicTokens = {\n  '.': TOK_DOT,\n  ',': TOK_COMMA,\n  ':': TOK_COLON,\n  '{': TOK_LBRACE,\n  '}': TOK_RBRACE,\n  ']': TOK_RBRACKET,\n  '(': TOK_LPAREN,\n  ')': TOK_RPAREN,\n  '@': TOK_CURRENT,\n};\n\nconst globalStartToken = '$';\nconst operatorStartToken = {\n  '<': true,\n  '>': true,\n  '=': true,\n  '!': true,\n};\n\nconst skipChars = {\n  ' ': true,\n  '\\t': true,\n  '\\n': true,\n};\n\nfunction isAlphaNum(ch) {\n  return (ch >= 'a' && ch <= 'z')\n    || (ch >= 'A' && ch <= 'Z')\n    || (ch >= '0' && ch <= '9')\n    || ch === '_';\n}\n\nfunction isIdentifier(stream, pos) {\n  const ch = stream[pos];\n  // $ is special -- it's allowed to be part of an identifier if it's the first character\n  // return whether character 'isAlpha'\n  return ch === '$'\n    || (ch >= 'a' && ch <= 'z')\n    || (ch >= 'A' && ch <= 'Z')\n    || ch === '_';\n}\n\nexport default class Lexer {\n  constructor(allowedGlobalNames = [], debug = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n    this.debug = debug;\n  }\n\n  tokenize(stream) {\n    const tokens = [];\n    this._current = 0;\n    let start;\n    let identifier;\n    let token;\n    while (this._current < stream.length) {\n      const prev = tokens.length ? tokens.slice(-1)[0].type : null;\n\n      if (this._isGlobal(prev, stream, this._current)) {\n        tokens.push(this._consumeGlobal(stream));\n      } else if (isIdentifier(stream, this._current)) {\n        start = this._current;\n        identifier = this._consumeUnquotedIdentifier(stream);\n        tokens.push({\n          type: TOK_IDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (this._isNumber(stream)) {\n        token = this._consumeNumber(stream);\n        tokens.push(token);\n      } else if (basicTokens[stream[this._current]] !== undefined) {\n        tokens.push({\n          type: basicTokens[stream[this._current]],\n          value: stream[this._current],\n          start: this._current,\n        });\n        this._current += 1;\n      } else if (stream[this._current] === '-' && ![TOK_GLOBAL, TOK_CURRENT, TOK_NUMBER, TOK_INT, TOK_RPAREN, TOK_IDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_RBRACKET, TOK_JSON, TOK_STRING].includes(prev)) {\n        token = this._consumeUnaryMinus(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '[') {\n        // No need to increment this._current.  This happens\n        // in _consumeLBracket\n        token = this._consumeLBracket(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === \"'\") {\n        start = this._current;\n        identifier = this._consumeQuotedIdentifier(stream);\n        tokens.push({\n          type: TOK_QUOTEDIDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === '\"') {\n        start = this._current;\n        identifier = this._consumeRawStringLiteral(stream);\n        tokens.push({\n          type: TOK_STRING,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === '`') {\n        start = this._current;\n        const json = this._consumeJson(stream);\n        tokens.push({\n          type: TOK_JSON,\n          value: json,\n          start,\n        });\n      } else if (operatorStartToken[stream[this._current]] !== undefined) {\n        tokens.push(this._consumeOperator(stream));\n      } else if (skipChars[stream[this._current]] !== undefined) {\n        // Ignore whitespace.\n        this._current += 1;\n      } else if (stream[this._current] === '&') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '&') {\n          this._current += 1;\n          tokens.push({ type: TOK_AND, value: '&&', start });\n        } else if (prev === TOK_COMMA || prev === TOK_LPAREN) {\n          // based on previous token we'll know if this & is a JMESPath expression-type\n          // or if it's a concatenation operator\n          // if we're a function arg then it's an expression-type\n          tokens.push({ type: TOK_EXPREF, value: '&', start });\n        } else {\n          tokens.push({ type: TOK_CONCATENATE, value: '&', start });\n        }\n      } else if (stream[this._current] === '~') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_UNION, value: '~', start });\n      } else if (stream[this._current] === '+') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_ADD, value: '+', start });\n      } else if (stream[this._current] === '-') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_SUBTRACT, value: '-', start });\n      } else if (stream[this._current] === '*') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_STAR, value: '*', start });\n      } else if (stream[this._current] === '/') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_DIVIDE, value: '/', start });\n      } else if (stream[this._current] === '|') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '|') {\n          this._current += 1;\n          tokens.push({ type: TOK_OR, value: '||', start });\n        } else {\n          tokens.push({ type: TOK_PIPE, value: '|', start });\n        }\n      } else {\n        throw syntaxError(`Unknown character:${stream[this._current]}`);\n      }\n    }\n    return tokens;\n  }\n\n  _consumeUnquotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (\n      this._current < stream.length\n      && (stream[this._current] === '$' || isAlphaNum(stream[this._current]))\n    ) {\n      this._current += 1;\n    }\n    return stream.slice(start, this._current);\n  }\n\n  _consumeQuotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    let foundNonAlpha = !isIdentifier(stream, start + 1);\n    while (stream[this._current] !== \"'\" && this._current < maxLength) {\n      // You can escape a single quote and you can escape an escape.\n      let current = this._current;\n      if (!isAlphaNum(stream[current])) foundNonAlpha = true;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n        || stream[current + 1] === \"'\")) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const val = stream.slice(start, this._current);\n    // Check for unnecessary single quotes.\n    // json-formula uses single quotes to escape characters that don't belong in names.\n    // e.g. \"purchase-order\".address\n    // If we find a single-quoted entity with spaces or all legal characters, issue a warning\n    try {\n      if (!foundNonAlpha) {\n        this.debug.push(`Suspicious quotes: ${val}`);\n        this.debug.push(`Did you intend a literal? \"${val.replace(/'/g, '')}\"?`);\n      }\n      // eslint-disable-next-line no-empty\n    } catch (e) { }\n    // we want to do all the escape-processing that JSON does ...\n    // except that JSON expects to escape double quotes, and our identifiers\n    // escape single quotes.\n    return JSON.parse(`\"${val.substring(1, val.length - 1).replace(/\\\\'/g, \"'\")}\"`);\n  }\n\n  _consumeRawStringLiteral(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (stream[this._current] !== '\"' && this._current < maxLength) {\n      // You can escape a double quote and you can escape an escape.\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n        || stream[current + 1] === '\"')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const literal = stream.slice(start + 1, this._current - 1);\n    if (this._current > maxLength) {\n      throw syntaxError(`Unterminated string literal at ${start}, \"${literal}`);\n    }\n    try {\n      return JSON.parse(`\"${literal}\"`);\n    } catch (_e) {\n      throw syntaxError(`Invalid string literal: ${literal}`);\n    }\n  }\n\n  _isNumber(stream) {\n    // if we see the first two characters are either a digit or radix, then we have a number\n    let ch = stream[this._current];\n    if (ch >= '0' && ch <= '9') return true;\n    if (ch !== '.') return false;\n    if (this._current === stream.length) return false;\n    ch = stream[this._current + 1];\n    return ch >= '0' && ch <= '9';\n  }\n\n  _consumeNumber(stream) {\n    const start = this._current;\n    const num = stream.slice(start);\n    const match = num.match(/^[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?/);\n    if (!match) throw syntaxError(`Invalid number: ${num}`);\n    const n = match[0];\n    this._current += n.length;\n    let value;\n    if (n.includes('.') || n.toLowerCase().includes('e')) {\n      value = parseFloat(n);\n      return { type: TOK_NUMBER, value, start };\n    }\n    value = parseInt(n, 10);\n    return { type: TOK_INT, value, start };\n  }\n\n  _consumeUnaryMinus() {\n    const start = this._current;\n    this._current += 1;\n    return { type: TOK_UNARY_MINUS, value: '-', start };\n  }\n\n  _consumeLBracket(stream) {\n    const start = this._current;\n    this._current += 1;\n    if (stream[this._current] === '?') {\n      this._current += 1;\n      return { type: TOK_FILTER, value: '[?', start };\n    }\n    if (stream[this._current] === ']') {\n      this._current += 1;\n      return { type: TOK_FLATTEN, value: '[]', start };\n    }\n    return { type: TOK_LBRACKET, value: '[', start };\n  }\n\n  _isGlobal(prev, stream, pos) {\n    // global tokens occur only at the start of an expression\n    if (prev !== null && prev === TOK_DOT) return false;\n    const ch = stream[pos];\n    if (ch !== globalStartToken) return false;\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    let i = pos + 1;\n    while (i < stream.length && (stream[i] === '$' || isAlphaNum(stream[i]))) i += 1;\n    const global = stream.slice(pos, i);\n    return this._allowedGlobalNames.includes(global);\n  }\n\n  _consumeGlobal(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length\n      && (stream[this._current] === '$' || isAlphaNum(stream[this._current]))) this._current += 1;\n    const global = stream.slice(start, this._current);\n\n    return { type: TOK_GLOBAL, name: global, start };\n  }\n\n  _consumeOperator(stream) {\n    const start = this._current;\n    const startingChar = stream[start];\n    this._current += 1;\n    if (startingChar === '!') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_COMPARATOR, value: '!=', start };\n      }\n      return { type: TOK_NOT, value: '!', start };\n    }\n    if (startingChar === '<') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_COMPARATOR, value: '<=', start };\n      }\n      if (stream[this._current] === '>') {\n        this._current += 1;\n        return { type: TOK_COMPARATOR, value: '!=', start };\n      }\n      return { type: TOK_COMPARATOR, value: '<', start };\n    }\n    if (startingChar === '>') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_COMPARATOR, value: '>=', start };\n      }\n      return { type: TOK_COMPARATOR, value: '>', start };\n    }\n    // startingChar is '='\n    if (stream[this._current] === '=') {\n      this._current += 1;\n    }\n    return { type: TOK_COMPARATOR, value: '==', start };\n  }\n\n  _consumeJson(stream) {\n    this._current += 1;\n    const start = this._current;\n    const maxLength = stream.length;\n    while (stream[this._current] !== '`' && this._current < maxLength) {\n      let current = this._current;\n      if (stream[current] === '\\\\' && stream[current + 1] === '`') {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    let literalString = stream.slice(start, this._current).trimStart();\n    literalString = literalString.replaceAll('\\\\`', '`');\n    // +1 gets us to the ending \"`\", +1 to move on to the next char.\n    this._current += 1;\n    if (this._current > maxLength) {\n      throw syntaxError(`Unterminated JSON literal at ${start}: \\`${literalString}`);\n    }\n\n    return JSON.parse(literalString);\n  }\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nimport Lexer from './Lexer.js';\nimport tokenDefinitions from './tokenDefinitions.js';\nimport { syntaxError } from './errors.js';\n\n/* eslint-disable no-underscore-dangle */\nconst {\n  TOK_JSON,\n  TOK_COLON,\n  TOK_EOF,\n  TOK_IDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_UNARY_MINUS,\n  TOK_MULTIPLY,\n  TOK_DIVIDE,\n  TOK_UNION,\n  TOK_COMPARATOR,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n  TOK_STRING,\n  TOK_INT,\n} = tokenDefinitions;\n\nconst bindingPower = {\n  [TOK_EOF]: 0,\n  [TOK_IDENTIFIER]: 0,\n  [TOK_QUOTEDIDENTIFIER]: 0,\n  [TOK_RBRACKET]: 0,\n  [TOK_RPAREN]: 0,\n  [TOK_COMMA]: 0,\n  [TOK_RBRACE]: 0,\n  [TOK_NUMBER]: 0,\n  [TOK_INT]: 0,\n  [TOK_CURRENT]: 0,\n  [TOK_GLOBAL]: 0,\n  [TOK_EXPREF]: 0,\n  [TOK_PIPE]: 1,\n  [TOK_OR]: 2,\n  [TOK_AND]: 3,\n  [TOK_COMPARATOR]: 4,\n  [TOK_CONCATENATE]: 5,\n  [TOK_ADD]: 6,\n  [TOK_SUBTRACT]: 6,\n  [TOK_UNION]: 6,\n  [TOK_MULTIPLY]: 7,\n  [TOK_DIVIDE]: 7,\n  [TOK_NOT]: 8,\n  [TOK_UNARY_MINUS]: 8,\n  [TOK_FLATTEN]: 10,\n  [TOK_STAR]: 20,\n  [TOK_FILTER]: 21,\n  [TOK_DOT]: 40,\n  [TOK_LBRACE]: 50,\n  [TOK_LBRACKET]: 55,\n  [TOK_LPAREN]: 60,\n};\n\nexport default class Parser {\n  constructor(allowedGlobalNames = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n  }\n\n  parse(expression, debug) {\n    this.debug = debug;\n    this._loadTokens(expression);\n    this.index = 0;\n    const ast = this.expression(0);\n    if (this._lookahead(0) !== TOK_EOF) {\n      const t = this._lookaheadToken(0);\n      throw syntaxError(`Unexpected token type: ${t.type}, value: ${t.value}`);\n    }\n    return ast;\n  }\n\n  _loadTokens(expression) {\n    const lexer = new Lexer(this._allowedGlobalNames, this.debug);\n    const tokens = lexer.tokenize(expression);\n    tokens.push({ type: TOK_EOF, value: '', start: expression.length });\n    this.tokens = tokens;\n  }\n\n  expression(rbp) {\n    const leftToken = this._lookaheadToken(0);\n    this._advance();\n    let left = this.nud(leftToken);\n    let currentToken = this._lookaheadToken(0, left);\n    while (rbp < bindingPower[currentToken.type]) {\n      this._advance();\n      left = this.led(currentToken, left);\n      currentToken = this._lookaheadToken(0, left);\n    }\n    return left;\n  }\n\n  _lookahead(number) {\n    return this.tokens[this.index + number].type;\n  }\n\n  _lookaheadToken(number, previous = {}) {\n    const next = this.tokens[this.index + number];\n    // disambiguate multiply and star\n    if (next.type === TOK_STAR) {\n      if (![\n        undefined,\n        TOK_LBRACKET,\n        TOK_DOT,\n        TOK_PIPE,\n        TOK_AND,\n        TOK_OR,\n        TOK_COMMA,\n        TOK_NOT,\n        TOK_MULTIPLY,\n        TOK_ADD,\n        TOK_SUBTRACT,\n        TOK_DIVIDE,\n        TOK_LPAREN,\n        TOK_CONCATENATE,\n        TOK_UNION,\n        TOK_COMPARATOR].includes(previous.type)) {\n        next.type = TOK_MULTIPLY;\n      }\n    }\n\n    return next;\n  }\n\n  _advance() {\n    this.index += 1;\n  }\n\n  _lookAheadIndex() {\n    let idx = 0;\n    if (this._lookahead(idx) === TOK_UNARY_MINUS) idx += 1;\n    if (this._lookahead(idx) === TOK_INT) idx += 1;\n    if (this._lookahead(idx) === TOK_RBRACKET\n      || this._lookahead(idx) === TOK_COLON) return true;\n    return false;\n  }\n\n  _getIndex() {\n    return this.index;\n  }\n\n  _setIndex(index) {\n    this.index = index;\n  }\n\n  // eslint-disable-next-line consistent-return\n  nud(token) {\n    let left;\n    let right;\n    let expression;\n    let node;\n    let args;\n    switch (token.type) {\n      case TOK_STRING:\n        return { type: 'String', value: token.value };\n      case TOK_JSON:\n        return { type: 'Literal', value: token.value };\n      case TOK_NUMBER:\n        return { type: 'Number', value: token.value };\n      case TOK_INT:\n        return { type: 'Integer', value: token.value };\n      case TOK_IDENTIFIER:\n        return { type: 'Identifier', name: token.value };\n      case TOK_QUOTEDIDENTIFIER:\n        node = { type: 'QuotedIdentifier', name: token.value };\n        return node;\n      case TOK_NOT:\n        right = this.expression(bindingPower.Not);\n        return { type: 'NotExpression', children: [right] };\n      case TOK_UNARY_MINUS:\n        right = this.expression(bindingPower.UnaryMinus);\n        return { type: 'UnaryMinusExpression', children: [right] };\n      case TOK_STAR:\n        left = { type: 'Identity' };\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          // This can happen in a ArrayExpression,\n          // [a, b, *]\n          right = { type: 'Identity' };\n        } else {\n          right = this._parseProjectionRHS(bindingPower.Star);\n        }\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_FILTER:\n        return this.led(token, { type: 'Identity' });\n      case TOK_LBRACE:\n        return this._parseObjectExpression();\n      case TOK_FLATTEN:\n        left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };\n        right = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [left, right] };\n      case TOK_LBRACKET:\n        if (this._lookAheadIndex()) {\n          right = this._parseIndexExpression();\n          return this._projectIfSlice({ type: 'Identity' }, right);\n        }\n        if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: 'Projection',\n            children: [{ type: 'Identity' }, right],\n            debug: 'Wildcard',\n          };\n        }\n        return this._parseArrayExpression();\n\n      case TOK_CURRENT:\n        return { type: TOK_CURRENT };\n      case TOK_GLOBAL:\n        return { type: TOK_GLOBAL, name: token.name };\n      case TOK_EXPREF:\n        expression = this.expression(bindingPower.Expref);\n        return { type: 'ExpressionReference', children: [expression] };\n      case TOK_LPAREN:\n        args = [];\n        while (this._lookahead(0) !== TOK_RPAREN) {\n          expression = this.expression(0);\n          args.push(expression);\n        }\n        this._match(TOK_RPAREN);\n        return args[0];\n      default:\n        this._errorToken(token);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  led(token, left) {\n    let condition;\n    let right;\n    let name;\n    let args;\n    let node;\n    let rbp;\n    let leftNode;\n    let rightNode;\n    const tokenName = token.type;\n    switch (tokenName) {\n      case TOK_CONCATENATE:\n        right = this.expression(bindingPower.Concatenate);\n        return { type: 'ConcatenateExpression', children: [left, right] };\n      case TOK_DOT:\n        rbp = bindingPower.Dot;\n        if (this._lookahead(0) !== TOK_STAR) {\n          right = this._parseDotRHS(rbp);\n          return { type: 'ChainedExpression', children: [left, right] };\n        }\n        // Creating a projection.\n        this._advance();\n        right = this._parseProjectionRHS(rbp);\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_PIPE:\n        right = this.expression(bindingPower.Pipe);\n        return { type: TOK_PIPE, children: [left, right] };\n      case TOK_OR:\n        right = this.expression(bindingPower.Or);\n        return { type: 'OrExpression', children: [left, right] };\n      case TOK_AND:\n        right = this.expression(bindingPower.And);\n        return { type: 'AndExpression', children: [left, right] };\n      case TOK_ADD:\n        right = this.expression(bindingPower.Add);\n        return { type: 'AddExpression', children: [left, right] };\n      case TOK_SUBTRACT:\n        right = this.expression(bindingPower.Subtract);\n        return { type: 'SubtractExpression', children: [left, right] };\n      case TOK_MULTIPLY:\n        right = this.expression(bindingPower.Multiply);\n        return { type: 'MultiplyExpression', children: [left, right] };\n      case TOK_DIVIDE:\n        right = this.expression(bindingPower.Divide);\n        return { type: 'DivideExpression', children: [left, right] };\n      case TOK_UNION:\n        right = this.expression(bindingPower.Union);\n        return { type: 'UnionExpression', children: [left, right] };\n      case TOK_LPAREN:\n        if (left.type !== TOK_IDENTIFIER) {\n          throw syntaxError('Bad function syntax. Parenthesis must be preceded by an unquoted identifier');\n        }\n        name = left.name;\n        args = this._parseFunctionArgs();\n        node = { type: 'Function', name, children: args };\n        return node;\n      case TOK_FILTER:\n        condition = this.expression(0);\n        this._match(TOK_RBRACKET);\n        right = this._parseProjectionRHS(bindingPower.Filter);\n        return { type: 'FilterProjection', children: [left, right, condition] };\n      case TOK_FLATTEN:\n        leftNode = { type: TOK_FLATTEN, children: [left] };\n        rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [leftNode, rightNode] };\n      case TOK_COMPARATOR:\n        return this._parseComparator(left, token);\n      case TOK_LBRACKET:\n        if (this._lookahead(0) === TOK_STAR\n            && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return { type: 'Projection', children: [left, right], debug: 'Wildcard' };\n        }\n        right = this._parseIndexExpression();\n        return this._projectIfSlice(left, right);\n      default:\n        this._errorToken(token);\n    }\n  }\n\n  _match(tokenType) {\n    const token = this._lookaheadToken(0);\n    if (token.type === tokenType) {\n      this._advance();\n      return token;\n    }\n    throw syntaxError(`Expected ${tokenType}, got: ${token.type}`);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _errorToken(token) {\n    throw syntaxError(`Unexpected token (${\n      token.type}): \"${\n      token.value || token.name}\"`);\n  }\n\n  _parseFunctionArgs() {\n    let firstExpression = true;\n    const args = [];\n    while (this._lookahead(0) !== TOK_RPAREN) {\n      if (!firstExpression) {\n        this._match(TOK_COMMA);\n      }\n      args.push(this.expression(0));\n      firstExpression = false;\n    }\n    this._match(TOK_RPAREN);\n    return args;\n  }\n\n  _parseSignedInt() {\n    const first = this._lookaheadToken(0);\n    if (first.type === TOK_UNARY_MINUS) {\n      this._advance();\n      const value = this._match(TOK_INT);\n      return {\n        type: 'SignedInt',\n        value: -value.value,\n      };\n    }\n    if (first.type !== TOK_INT) this._errorToken(first);\n    this._advance();\n    return {\n      type: 'SignedInt',\n      value: first.value,\n    };\n  }\n\n  _parseIndexExpression() {\n    const oldIndex = this._getIndex();\n    if (this._lookahead(0) === TOK_COLON) {\n      return this._parseSliceExpression();\n    }\n    // look ahead of the first expression to determine the type\n    const first = this._parseSignedInt();\n    const token = this._lookahead(0);\n    if (token === TOK_COLON) {\n      // now that we know the type revert back to the old position and parse\n      this._setIndex(oldIndex);\n      return this._parseSliceExpression();\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Index',\n      value: first,\n    };\n  }\n\n  _projectIfSlice(left, right) {\n    const indexExpr = { type: 'BracketExpression', children: [left, right] };\n    if (right.type === 'Slice') {\n      return {\n        type: 'Projection',\n        children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],\n      };\n    }\n    return indexExpr;\n  }\n\n  _parseSliceExpression() {\n    // [start:end:step] where each part is optional, as well as the last\n    // colon.\n    const parts = [null, null, null];\n    let index = 0;\n    let currentToken = this._lookahead(0);\n    while (currentToken !== TOK_RBRACKET && index < 3) {\n      if (currentToken === TOK_COLON && index < 2) { // there can't be more than 2 colons\n        index += 1;\n        this._advance();\n      } else {\n        parts[index] = this._parseSignedInt();\n        // check next token to be either colon or rbracket\n        const t = this._lookahead(0);\n        if (t !== TOK_COLON && t !== TOK_RBRACKET) {\n          throw syntaxError(`Unexpected token: ${\n            t.value}(${t.type})`);\n        }\n      }\n      currentToken = this._lookahead(0);\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Slice',\n      children: parts,\n    };\n  }\n\n  _parseComparator(left, comparator) {\n    const right = this.expression(bindingPower[comparator.type]);\n    return { type: 'Comparator', value: comparator.value, children: [left, right] };\n  }\n\n  _parseDotRHS(rbp) {\n    const lookahead = this._lookahead(0);\n    const exprTokens = [TOK_IDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n    if (exprTokens.indexOf(lookahead) >= 0) {\n      return this.expression(rbp);\n    }\n    if (lookahead === TOK_LBRACKET) {\n      this._match(TOK_LBRACKET);\n      return this._parseArrayExpression();\n    }\n    if (lookahead === TOK_LBRACE) {\n      this._match(TOK_LBRACE);\n      return this._parseObjectExpression();\n    }\n    throw syntaxError('Expecting one of: \"*\", \"[\", \"{\", name or quoted name after a dot');\n  }\n\n  _parseProjectionRHS(rbp) {\n    let right;\n    const next = this._lookaheadToken(0, { type: TOK_STAR });\n    if (bindingPower[next.type] <= bindingPower[TOK_FLATTEN]) {\n      right = { type: 'Identity' };\n    } else if (next.type === TOK_LBRACKET) {\n      right = this.expression(rbp);\n    } else if (next.type === TOK_FILTER) {\n      right = this.expression(rbp);\n    } else if (next.type === TOK_DOT) {\n      this._match(TOK_DOT);\n      right = this._parseDotRHS(rbp);\n    } else {\n      throw syntaxError(`Unexpected token: ${next.value}(${next.type})`);\n    }\n    return right;\n  }\n\n  _parseArrayExpression() {\n    const expressions = [];\n    while (this._lookahead(0) !== TOK_RBRACKET) {\n      const expression = this.expression(0);\n      expressions.push(expression);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          throw syntaxError('Unexpected token Rbracket');\n        }\n      }\n    }\n    this._match(TOK_RBRACKET);\n    return { type: 'ArrayExpression', children: expressions };\n  }\n\n  _parseObjectExpression() {\n    const pairs = [];\n    const identifierTypes = [TOK_IDENTIFIER, TOK_QUOTEDIDENTIFIER];\n    let keyToken; let keyName; let value; let\n      node;\n    if (this._lookahead(0) === TOK_RBRACE) {\n      this.debug.push('To create an empty object, use a JSON literal: `{}`');\n      throw syntaxError('An empty object expression is not allowed');\n    }\n    for (;;) {\n      keyToken = this._lookaheadToken(0);\n      if (identifierTypes.indexOf(keyToken.type) < 0) {\n        throw syntaxError(`Expecting an identifier token, got: ${\n          keyToken.type}`);\n      }\n      keyName = keyToken.value;\n      this._advance();\n      this._match(TOK_COLON);\n      value = this.expression(0);\n      node = { type: 'KeyValuePair', name: keyName, value };\n      pairs.push(node);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n      } else if (this._lookahead(0) === TOK_RBRACE) {\n        this._match(TOK_RBRACE);\n        break;\n      }\n    }\n    return { type: 'ObjectExpression', children: pairs };\n  }\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable no-underscore-dangle */\nimport { dataTypes, typeNameTable } from './dataTypes.js';\nimport {\n  getProperty, debugAvailable, toBoolean, strictDeepEqual,\n} from './utils.js';\nimport { evaluationError, functionError, typeError } from './errors.js';\n\nfunction round(num, digits) {\n  const precision = 10 ** digits;\n  return Math.round(num * precision) / precision;\n}\n\nconst MS_IN_DAY = 24 * 60 * 60 * 1000;\n\nfunction getDateObj(dateNum) {\n  return new Date(Math.round(dateNum * MS_IN_DAY));\n}\n\nfunction getDateNum(dateObj) {\n  return dateObj / MS_IN_DAY;\n}\n\nfunction validNumber(n, context) {\n  if (Number.isNaN(n) || !Number.isFinite(n)) {\n    throw evaluationError(`Call to \"${context}()\" resulted in an invalid number`);\n  }\n  return n;\n}\n\nexport default function functions(\n  runtime,\n  isObject,\n  toNumber,\n  getType,\n  isArrayType,\n  valueOf,\n  toString,\n  debug,\n) {\n  const {\n    TYPE_NUMBER,\n    TYPE_ANY,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT,\n    TYPE_BOOLEAN,\n    TYPE_EXPREF,\n    TYPE_NULL,\n    TYPE_ARRAY_NUMBER,\n    TYPE_ARRAY_STRING,\n    TYPE_ARRAY_ARRAY,\n  } = dataTypes;\n\n  function toInteger(num) {\n    let n = valueOf(num);\n    // functions that require an integer parameter will have declared\n    // the parameters as a number, so any strings will have already been\n    // converted to number before the function call.\n    // However, a few functions accept a string | integer. Attempt to convert\n    // to integer in these cases, but failure isn't an error.\n    if (getType(n) === TYPE_STRING) n = toNumber(n);\n    n = Math.trunc(num);\n    if (Number.isNaN(n)) return num;\n    return n;\n  }\n\n  function toJSON(arg, indent) {\n    const value = valueOf(arg);\n    if (getType(value) === TYPE_STRING) {\n      return arg;\n    }\n    const offset = indent ? toInteger(indent) : 0;\n    return JSON.stringify(value, null, offset);\n  }\n\n  const functionMap = {\n    // name: [function, <signature>]\n    // The <signature> can be:\n    //\n    // {\n    //   args: [[type1, type2], [type1, type2]],\n    //   variadic: true|false\n    // }\n    //\n    // Each arg in the arg list is a list of valid types\n    // (if the function is overloaded and supports multiple\n    // types.  If the type is \"any\" then no type checking\n    // occurs on the argument.  Variadic is optional\n    // and if not provided is assumed to be false.\n    /**\n     * Find the absolute (non-negative) value of the provided argument `value`.\n     * @param {number} value a numeric value\n     * @return {number} If `value < 0`, returns `-value`, otherwise returns `value`\n     * @function abs\n     * @example\n     * abs(-1) // returns 1\n     */\n    abs: {\n      _func: resolvedArgs => Math.abs(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    /**\n     * Compute the inverse cosine (in radians) of a number.\n     * @param {number} cosine A number between -1 and 1, inclusive,\n     * representing the angle's cosine value.\n     * @return {number} The inverse cosine angle in radians between 0 and PI\n     * @function acos\n     * @example\n     * acos(0) => 1.5707963267948966\n     */\n    acos: {\n      _func: resolvedArgs => validNumber(Math.acos(resolvedArgs[0]), 'acos'),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Finds the logical AND result of all parameters.\n     * If the parameters are not boolean they will be <<_type_coercion_rules,cast to boolean>>.\n     * Note the related <<_and_operator, And Operator>>.\n     * @param {any} firstOperand logical expression\n     * @param {...any} [additionalOperands] any number of additional expressions\n     * @returns {boolean} The logical result of applying AND to all parameters\n     * @example\n     * and(10 > 8, length(\"foo\") < 5) // returns true\n     * and(`null`, length(\"foo\") < 5) // returns false\n     * @function and\n     */\n    and: {\n      _func: resolvedArgs => {\n        let result = toBoolean(valueOf(resolvedArgs[0]));\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result && toBoolean(valueOf(arg));\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n\n    /**\n     * Compute the inverse sine (in radians) of a number.\n     * @param {number} sine A number between -1 and 1, inclusive,\n     * representing the angle's sine value.\n     * @return {number} The inverse sine angle in radians between -PI/2 and PI/2\n     * @function asin\n     * @example\n     * Math.asin(0) => 0\n     */\n    asin: {\n      _func: resolvedArgs => validNumber(Math.asin(resolvedArgs[0]), 'asin'),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Compute the angle in the plane (in radians) between the positive\n     * x-axis and the ray from (0, 0) to the point (x, y)\n     * @param {number} y The y coordinate of the point\n     * @param {number} x The x coordinate of the point\n     * @return {number} The angle in radians (between -PI and PI),\n     * between the positive x-axis and the ray from (0, 0) to the point (x, y).\n     * @function atan2\n     * @example\n     * atan2(20,10) => 1.1071487177940904\n     */\n    atan2: {\n      _func: resolvedArgs => Math.atan2(resolvedArgs[0], resolvedArgs[1]),\n      _signature: [\n        { types: [TYPE_NUMBER] },\n        { types: [TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Finds the average of the elements in an array.\n     * If the array is empty, an evaluation error is thrown\n     * @param {number[]} elements array of numeric values\n     * @return {number} average value\n     * @function avg\n     * @example\n     * avg([1, 2, 3]) // returns 2\n     */\n    avg: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        const inputArray = resolvedArgs[0];\n        if (inputArray.length === 0) throw evaluationError('avg() requires at least one argument');\n        inputArray.forEach(a => {\n          sum += a;\n        });\n        return sum / inputArray.length;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n\n    /**\n     * Generates a lower-case string of the `input` string using locale-specific mappings.\n     * e.g. Strings with German letter <span>&#223;</span> (eszett) can be compared to \"ss\"\n     * @param {string} input string to casefold\n     * @returns {string} A new string converted to lower case\n     * @function casefold\n     * @example\n     * casefold(\"AbC\") // returns \"abc\"\n     */\n    casefold: {\n      _func: (args, _data, interpreter) => {\n        const str = toString(args[0]);\n        return str.toLocaleUpperCase(interpreter.language).toLocaleLowerCase(interpreter.language);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Finds the next highest integer value of the argument `num` by rounding up if necessary.\n     * i.e. ceil() rounds toward positive infinity.\n     * @param {number} num numeric value\n     * @return {integer} The smallest integer greater than or equal to num\n     * @function ceil\n     * @example\n     * ceil(10) // returns 10\n     * ceil(10.4) // return 11\n\n     */\n    ceil: {\n      _func: resolvedArgs => Math.ceil(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    /**\n     * Retrieve the first code point from a string\n     * @param {string} str source string.\n     * @return {integer} Unicode code point value. If the input string is empty, returns `null`.\n     * @function codePoint\n     * @example\n     * codePoint(\"ABC\") // 65\n     */\n    codePoint: {\n      _func: args => {\n        const text = toString(args[0]);\n        return text.length === 0 ? null : text.codePointAt(0);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Determines if the given `subject` contains `search`.\n     * If `subject` is an array, this function returns true if one of the elements\n     * in the array is equal to the `search` value. If `subject`\n     * is a string, return true if the string contains the\n     * `search` value.\n     * @param {array|string} subject The element to be searched\n     * @param {any} search element to find.\n     * If `subject` is an array, search for an exact match for `search` in the array.\n     * If `subject` is a string, `search` must also be a string.\n     * @return {boolean} true if found\n     * @function contains\n     * @example\n     * contains([1, 2, 3, 4], 2) // returns true\n     * contains([1, 2, 3, 4], -1) // returns false\n     * contains(\"Abcd\", \"d\") // returns true\n     * contains(\"Abcd\", \"x\") // returns false\n\n     */\n    contains: {\n      _func: resolvedArgs => {\n        const subject = valueOf(resolvedArgs[0]);\n        const search = valueOf(resolvedArgs[1]);\n        if (isArrayType(resolvedArgs[0])) {\n          return subject.some(s => strictDeepEqual(s, search));\n        }\n        const source = Array.from(subject);\n        if (getType(search) !== TYPE_STRING) {\n          throw typeError('contains() requires a string search value for string subjects');\n        }\n        if (search === '') return true;\n        const searchLen = Array.from(search).length;\n        for (let i = 0; i < source.length; i += 1) {\n          if (source.slice(i, i + searchLen).join('') === search) return true;\n        }\n        return false;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },\n        { types: [TYPE_ANY] }],\n    },\n    /**\n     * Compute the cosine (in radians) of a number.\n     * @param {number} angle A number representing an angle in radians\n     * @return {number} The cosine of the angle, between -1 and 1, inclusive.\n     * @function cos\n     * @example\n     * cos(1.0471975512) => 0.4999999999970535\n     */\n    cos: {\n      _func: resolvedArgs => Math.cos(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Return difference between two date values.\n     * The measurement of the difference is determined by the `unit` parameter. One of:\n     *\n     * * `y` the number of whole years between `start_date` and `end_date`\n     * * `m` the number of whole months between `start_date` and `end_date`.\n     * * `d` the number of days between `start_date` and `end_date`\n     * * `ym` the number of whole months between `start_date` and `end_date`\n     * after subtracting whole years.\n     * * `yd` the number of days between `start_date` and `end_date`, assuming `start_date`\n     * and `end_date` were no more than one year apart\n     * @param {number} start_date The starting <<_date_and_time_values, date/time value>>.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @param {number} end_date The end <<_date_and_time_values, date/time value>> -- must\n     * be greater or equal to start_date. If not, an error will be thrown.\n     * @param {string} unit Case-insensitive string representing the unit of time to measure.\n     * An unrecognized unit will result in an error.\n     * @returns {integer} The number of days/months/years difference\n     * @function datedif\n     * @example\n     * datedif(datetime(2001, 1, 1), datetime(2003, 1, 1), \"y\") // returns 2\n     * datedif(datetime(2001, 6, 1), datetime(2003, 8, 15), \"D\") // returns 805\n     * // 805 days between June 1, 2001, and August 15, 2003\n     * datedif(datetime(2001, 6, 1), datetime(2003, 8, 15), \"YD\") // returns 75\n     * // 75 days between June 1 and August 15, ignoring the years of the dates (75)\n     */\n    datedif: {\n      _func: args => {\n        const unit = toString(args[2]).toLowerCase();\n        const date1 = getDateObj(args[0]);\n        const date2 = getDateObj(args[1]);\n        if (date2 === date1) return 0;\n        if (date2 < date1) throw functionError('end_date must be >= start_date in datedif()');\n\n        if (unit === 'd') return Math.floor(getDateNum(date2 - date1));\n        const yearDiff = date2.getFullYear() - date1.getFullYear();\n        let monthDiff = date2.getMonth() - date1.getMonth();\n        const dayDiff = date2.getDate() - date1.getDate();\n\n        if (unit === 'y') {\n          let y = yearDiff;\n          if (monthDiff < 0) y -= 1;\n          if (monthDiff === 0 && dayDiff < 0) y -= 1;\n          return y;\n        }\n        if (unit === 'm') {\n          return yearDiff * 12 + monthDiff + (dayDiff < 0 ? -1 : 0);\n        }\n        if (unit === 'ym') {\n          if (dayDiff < 0) monthDiff -= 1;\n          if (monthDiff <= 0 && yearDiff > 0) return 12 + monthDiff;\n          return monthDiff;\n        }\n        if (unit === 'yd') {\n          if (dayDiff < 0) monthDiff -= 1;\n          if (monthDiff < 0) date2.setFullYear(date1.getFullYear() + 1);\n          else date2.setFullYear(date1.getFullYear());\n          return Math.floor(getDateNum(date2 - date1));\n        }\n        throw functionError(`Unrecognized unit parameter \"${unit}\" for datedif()`);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Generate a date/time value from individual date/time parts.\n     * If any of the units are greater than their normal range,\n     * the overflow will be added to the next greater unit.\n     * e.g. specifying 25 hours will increment the day value by 1.\n     * Similarly,\n     * negative values will decrement the next greater unit.\n     * e.g. datetime(year, month, day - 30) will return a date 30 days earlier.\n     * @param {integer} year The year to use for date construction.\n     * Values from 0 to 99 map to the years 1900 to 1999. All other values are the actual year\n     * @param {integer} month The month: beginning with 1 for\n     * January to 12 for December.\n     * @param {integer} day The day of the month.\n     * @param {integer} [hours=0] Integer value between 0 and 23 representing the hour of the day.\n     * @param {integer} [minutes=0] Integer value representing the minute segment of a time.\n     * @param {integer} [seconds=0] Integer value representing the second segment of a time.\n     * @param {integer} [milliseconds=0] Integer value representing the\n     * millisecond segment of a time.\n     * @returns {number} A <<_date_and_time_values, date/time value>>\n     * to be used with other date/time functions\n     * @function datetime\n     * @example\n     * datetime(2010, 10, 10) // returns representation of October 10, 2010\n     * datetime(2010, 2, 28) // returns representation of February 28, 2010\n     * datetime(2023,13,5) | year(@) & \"/\" & month(@) // returns 2024/1\n     */\n    datetime: {\n      _func: args => {\n        const year = toInteger(args[0]);\n        const month = toInteger(args[1]) - 1; // javascript months start from 0\n        const day = toInteger(args[2]);\n        const hours = args.length > 3 ? toInteger(args[3]) : 0;\n        const minutes = args.length > 4 ? toInteger(args[4]) : 0;\n        const seconds = args.length > 5 ? toInteger(args[5]) : 0;\n        const ms = args.length > 6 ? toInteger(args[6]) : 0;\n\n        const baseDate = new Date(year, month, day, hours, minutes, seconds, ms);\n\n        return getDateNum(baseDate);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Finds the day of the month for a date value\n     * @param {number} date <<_date_and_time_values, date/time value>> generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} The day of the month ranging from 1 to 31.\n     * @function day\n     * @example\n     * day(datetime(2008,5,23)) // returns 23\n     */\n    day: {\n      _func: args => getDateObj(args[0]).getDate(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Debug a json-formula expression.\n     * The `debug()` function allows users to inspect a sub-expression within a formula.\n     * @param {any} arg The expression to return from `debug()` function,\n     * and the default expression to be debugged. May be any type except an expression.\n     * @param {any|expression} [displayValue=arg] Optionally override the value to be debugged.\n     * `displayValue` may be an expression to\n     * be evaluated with the context of `arg`.\n     * @returns {any} The value of the `arg` parameter\n     * @function debug\n     * @example\n     * avg(([1,2,3] * [2,3,4]).debug(@)).round(@,3) // 6.667\n     * avg(debug([1,2,3] * [2,3,4],&\"average of: \" &toString(@))).round(@,3) // 6.667\n     */\n    debug: {\n      _func: resolvedArgs => {\n        const arg = resolvedArgs[0];\n        if (resolvedArgs.length > 1) {\n          if (getType(resolvedArgs[1]) === TYPE_EXPREF) {\n            debug.push(runtime.interpreter.visit(resolvedArgs[1], arg));\n          } else {\n            debug.push(resolvedArgs[1]);\n          }\n        } else {\n          debug.push(toJSON(resolvedArgs[0]));\n        }\n        return arg;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY, dataTypes.TYPE_EXPREF], optional: true },\n      ],\n    },\n\n    /**\n     * Performs a depth-first search of a nested hierarchy to\n     * return an array of key values that match a `name`.\n     * The name can be either a key into an object or an array index.\n     * This is similar to the Descendant Accessor operator (`..`) from [E4X](https://ecma-international.org/publications-and-standards/standards/ecma-357/).\n     * @param {object|array|null} object The starting object or array where we start the search\n     * @param {string|integer} name The name (or index position) of the elements to find.\n     * If `name` is a string, search for nested objects with a matching key.\n     * If `name` is an integer, search for nested arrays with a matching index.\n     * @returns {any[]} The array of matched elements\n     * @function deepScan\n     * @example\n     * deepScan({a : {b1 : {c : 2}, b2 : {c : 3}}}, \"c\") // returns [2, 3]\n     */\n    deepScan: {\n      _func: resolvedArgs => {\n        const [source, n] = resolvedArgs;\n        const [name, checkArrays] = getType(n) === TYPE_NUMBER\n          ? [toInteger(n), true] : [toString(n), false];\n        const items = [];\n        function scan(node) {\n          if (node === null) return;\n          if (isArrayType(node)) {\n            if (checkArrays && node[name] !== undefined) items.push(node[name]);\n            node.forEach(scan);\n          } else if (isObject(node)) {\n            Object.entries(node).forEach(([k, v]) => {\n              if (!checkArrays && k === name) items.push(v);\n              scan(v);\n            });\n          }\n        }\n        scan(source);\n        return items;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_OBJECT, dataTypes.TYPE_ARRAY, dataTypes.TYPE_NULL] },\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Determines if the `subject` string ends with a specific `suffix`\n     * @param {string} subject source string in which to search\n     * @param {string} suffix search string\n     * @return {boolean} true if the `suffix` value is at the end of the `subject`\n     * @function endsWith\n     * @example\n     * endsWith(\"Abcd\", \"d\") // returns true\n     * endsWith(\"Abcd\", \"A\") // returns false\n     */\n    endsWith: {\n      _func: resolvedArgs => {\n        const searchStr = valueOf(resolvedArgs[0]);\n        const suffix = valueOf(resolvedArgs[1]);\n        // make sure the comparison is based on code points\n        const search = Array.from(searchStr).reverse();\n        const ending = Array.from(suffix).reverse();\n        return ending.every((c, i) => c === search[i]);\n      },\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    /**\n     * Returns an array of `[key, value]` pairs from an object or array.\n     * The `fromEntries()` function may be used to convert an array to an object.\n     * @param {object|array} obj source object or array\n     * @returns {any[]} an array of arrays where each child array has two elements\n     * representing the key and value of a pair\n     * @function entries\n     * @example\n     * entries({a: 1, b: 2}) // returns [[\"a\", 1], [\"b\", 2]]\n     * entries([4,5]) // returns [[\"0\", 4],[\"1\", 5]]\n     */\n    entries: {\n      _func: args => {\n        const obj = valueOf(args[0]);\n        return Object.entries(obj);\n      },\n      _signature: [\n        {\n          types: [\n            dataTypes.TYPE_ARRAY,\n            dataTypes.TYPE_OBJECT,\n          ],\n        },\n      ],\n    },\n\n    /**\n     * Finds the date value of the end of a month, given `startDate` plus `monthAdd` months\n     * @param {number} startDate The base date to start from.\n     * <<_date_and_time_values, Date/time values>> can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @param {integer} monthAdd Number of months to add to start date\n     * @return {number} the date of the last day of the month\n     * @function eomonth\n     * @example\n     * eomonth(datetime(2011, 1, 1), 1) | [month(@), day(@)] // returns [2, 28]\n     * eomonth(datetime(2011, 1, 1), -3) | [month(@), day(@)] // returns [10, 31]\n     */\n    eomonth: {\n      _func: args => {\n        const jsDate = getDateObj(args[0]);\n        const months = toInteger(args[1]);\n        // We can give the constructor a month value > 11 and it will increment the years\n        // Since day is 1-based, giving zero will yield the last day of the previous month\n        const newDate = new Date(jsDate.getFullYear(), jsDate.getMonth() + months + 1, 0);\n        return getDateNum(newDate);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Finds e (the base of natural logarithms) raised to a power. (i.e. e^x)\n     * @param {number} x A numeric expression representing the power of e.\n     * @returns {number} e (the base of natural logarithms) raised to power x\n     * @function exp\n     * @example\n     * exp(10) // returns 22026.465794806718\n     */\n    exp: {\n      _func: args => Math.exp(args[0]),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Return constant boolean false value.\n     * Expressions may also use the JSON literal: `` `false` ``\n     * @returns {boolean} constant boolean value `false`\n     * @function false\n     */\n    false: {\n      _func: () => false,\n      _signature: [],\n    },\n\n    /**\n     * Finds and returns the index of query in text from a start position\n     * @param {string} findText string to search\n     * @param {string} withinText text to be searched\n     * @param {integer} [start=0] zero-based position to start searching.\n     * If specified, `start` must be greater than or equal to 0\n     * @returns {integer|null} The position of the found string, null if not found.\n     * @function find\n     * @example\n     * find(\"m\", \"abm\") // returns 2\n     * find(\"M\", \"abMcdM\", 3) // returns 5\n     * find(\"M\", \"ab\") // returns `null`\n     * find(\"M\", \"abMcdM\", 2) // returns 2\n     */\n    find: {\n      _func: args => {\n        const query = Array.from(toString(args[0]));\n        const text = Array.from(toString(args[1]));\n        const offset = args.length > 2 ? toInteger(args[2]) : 0;\n        if (offset < 0) throw evaluationError('find() start position must be >= 0');\n        if (query.length === 0) {\n          // allow an empty string to be found at any position -- including the end\n          if (offset > text.length) return null;\n          return offset;\n        }\n        for (let i = offset; i < text.length; i += 1) {\n          if (text.slice(i, i + query.length).every((c, j) => c === query[j])) {\n            return i;\n          }\n        }\n        return null;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Calculates the next lowest integer value of the argument `num` by rounding down if necessary.\n     * i.e. floor() rounds toward negative infinity.\n     * @param {number} num numeric value\n     * @return {integer} The largest integer smaller than or equal to num\n     * @function floor\n     * @example\n     * floor(10.4) // returns 10\n     * floor(10) // returns 10\n     */\n    floor: {\n      _func: resolvedArgs => Math.floor(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Create a string from a code point.\n     * @param {integer} codePoint An integer between 0 and 0x10FFFF (inclusive)\n     * representing a Unicode code point.\n     * @return {string} A string from a given code point\n     * @function fromCodePoint\n     * @example\n     * fromCodePoint(65) // \"A\"\n     * fromCodePoint(65) == \"\\u0041\" // true\n     */\n    fromCodePoint: {\n      _func: args => {\n        const code = toInteger(args[0]);\n        try {\n          return String.fromCodePoint(code);\n        } catch (e) {\n          throw evaluationError(`Invalid code point: \"${code}\"`);\n        }\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Returns an object by transforming a list of key-value `pairs` into an object.\n     * `fromEntries()` is the inverse operation of `entries()`.\n     * If the nested arrays are not of the form: `[key, value]`\n     * (where key is a string), an error will be thrown.\n     * @param {any[]} pairs A nested array of key-value pairs to create the object from\n     * The nested arrays must have exactly two values, where the first value is a string.\n     * If a key is specified more than once, the last occurrence will override any previous value.\n     * @returns {object} An object constructed from the provided key-value pairs\n     * @function fromEntries\n     * @example\n     * fromEntries([[\"a\", 1], [\"b\", 2]]) // returns {a: 1, b: 2}\n     */\n    fromEntries: {\n      _func: args => {\n        const array = args[0];\n        // validate beyond the TYPE_ARRAY_ARRAY check\n        if (!array.every(a => {\n          if (a.length !== 2) return false;\n          if (getType(a[0]) !== TYPE_STRING) return false;\n          return true;\n        })) {\n          throw typeError('fromEntries() requires an array of key value pairs');\n        }\n        return Object.fromEntries(array);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_ARRAY] },\n      ],\n    },\n\n    /**\n     * Compute the nearest 32-bit single precision float representation of a number\n     * @param {number} num input to be rounded\n     * @return {number} The rounded representation of `num`\n     * @function fround\n     * @example\n     * fround(2147483650.987) => 2147483648\n     * fround(100.44444444444444444444) => 100.44444274902344\n     */\n    fround: {\n      _func: resolvedArgs => Math.fround(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Determine if an object has a property or if an array index is in range.\n     * @param {object|array|null} obj source object or array.\n     * @param {string|integer} name The name (or index position) of the element to find.\n     * if `obj` is an array, name must be an integer; if `obj` is an object, name must be a string.\n     * @returns {boolean} true if the element exists\n     * @function hasProperty\n     * @example\n     * hasProperty({a: 1, b: 2}, \"a\") // returns true\n     * hasProperty([\"apples\", \"oranges\"], 3) // returns false\n     * hasProperty(`null`, \"a\") // returns false\n     */\n    hasProperty: {\n      _func: args => {\n        let key = args[1];\n        const keyType = getType(key);\n\n        // if the object/array has a getter for this property then don't validate types\n        if (args[0] !== null && Object.getOwnPropertyDescriptor(args[0], key)?.get) return true;\n        const obj = valueOf(args[0]);\n        if (obj === null) return false;\n        const isArray = isArrayType(obj);\n        if (!(isArray || getType(obj) === dataTypes.TYPE_OBJECT)) {\n          throw typeError('First parameter to hasProperty() must be either an object or array.');\n        }\n\n        if (isArray) {\n          if (keyType !== TYPE_NUMBER) throw TypeError('hasProperty(): Array index must be an integer');\n          key = toInteger(key);\n        } else if (keyType !== TYPE_STRING) throw TypeError('hasProperty(): Object key must be a string');\n        const result = getProperty(obj, key);\n        return result !== undefined;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    /**\n     * Extract the hour from a <<_date_and_time_values, date/time value>>\n     * @param {number} date The datetime/time for which the hour is to be returned.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} value between 0 and 23\n     * @function hour\n     * @example\n     * hour(datetime(2008,5,23,12, 0, 0)) // returns 12\n     * hour(time(12, 0, 0)) // returns 12\n     */\n    hour: {\n      _func: args => getDateObj(args[0]).getHours(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Return one of two values `result1` or `result2`, depending on the `condition`\n     * @param {any} condition boolean result of a logical expression\n     * @param {any} result1 if condition is true\n     * @param {any} result2 if condition is false\n     * @return {any} either result1 or result2\n     * @function if\n\n     * @example\n     * if(true(), 1, 2) // returns 1\n     * if(false(), 1, 2) // returns 2\n     */\n    if: {\n      _func: (unresolvedArgs, data, interpreter) => {\n        const conditionNode = unresolvedArgs[0];\n        const leftBranchNode = unresolvedArgs[1];\n        const rightBranchNode = unresolvedArgs[2];\n        unresolvedArgs\n          .forEach(arg => {\n            if (arg.type === 'ExpressionReference') {\n              throw typeError('\"if()\" does not accept an expression reference argument.');\n            }\n          });\n\n        const condition = interpreter.visit(conditionNode, data);\n        if (toBoolean(valueOf(condition))) {\n          return interpreter.visit(leftBranchNode, data);\n        }\n        return interpreter.visit(rightBranchNode, data);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Combines all the elements from the provided\n     * array, joined together using the `glue` argument as a separator between each array element.\n     * @param {any[]} array array of values that will be converted to strings using `toString()`\n     * @param {string} glue\n     * @return {string} String representation of the array\n     * @function join\n     * @example\n     * join([\"a\", \"b\", \"c\"], \",\") // returns \"a,b,c\"\n     * join([\"apples\", \"bananas\"], \" and \") // returns \"apples and bananas\"\n     * join([1, 2, 3, null()], \"|\") // returns \"1|2|3|null\"\n     */\n    join: {\n      _func: resolvedArgs => {\n        const listJoin = resolvedArgs[0];\n        const joinChar = resolvedArgs[1];\n        return listJoin.map(a => toJSON(a)).join(joinChar);\n      },\n      _signature: [\n        { types: [TYPE_ARRAY] },\n        { types: [TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Generates an array of the keys of the input object. If the\n     * object is null, the value return an empty array\n     * @param {object} obj the object to examine\n     * @return {array} the array of all the key names\n     * @function keys\n     * @example\n     * keys({a : 3, b : 4}) // returns [\"a\", \"b\"]\n     */\n    keys: {\n      _func: resolvedArgs => Object.keys(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_OBJECT] }],\n    },\n    /**\n     * Return a substring from the start of a string or the left-most elements of an array\n     * @param {string|array} subject The source text/array of code points/elements\n     * @param {integer} [elements=1] number of elements to pick\n     * @return {string|array}\n     * @function left\n     * @example\n     * left(\"Sale Price\", 4) // returns \"Sale\"\n     * left(\"Sweden\") // returns \"S\"\n     * left([4, 5, 6], 2) // returns [4, 5]\n     */\n    left: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toInteger(args[1]) : 1;\n        if (numEntries < 0) throw evaluationError('left() requires a non-negative number of elements');\n        if (isArrayType(args[0])) return args[0].slice(0, numEntries);\n        const text = Array.from(toString(args[0]));\n        return text.slice(0, numEntries).join('');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Calculates the length of the input argument based on types:\n     *\n     * * string: returns the number of unicode code points\n     * * array: returns the number of array elements\n     * * object: returns the number of key-value pairs\n     * @param {string | array | object} subject subject whose length to calculate\n     * @return {integer} the length of the input subject\n     * @function length\n     * @example\n     * length(`[]`) // returns 0\n     * length(\"\") // returns 0\n     * length(\"abcd\") // returns 4\n     * length([1, 2, 3, 4]) // returns 4\n     * length(`{}`) // returns 0\n     * length({a : 3, b : 4}) // returns 2\n     */\n    length: {\n      _func: resolvedArgs => {\n        const arg = valueOf(resolvedArgs[0]);\n        if (isObject(arg)) return Object.keys(arg).length;\n        // Array.from splits a string into code points\n        // If we didn't do this, then String.length would return the number of UTF-16 code units\n        return isArrayType(arg) ? arg.length : Array.from(toString(arg)).length;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],\n    },\n\n    /**\n     * Compute the natural logarithm (base e) of a number\n     * @param {number} num A number greater than zero\n     * @return {number} The natural log value\n     * @function log\n     * @example\n     * log(10) // 2.302585092994046\n     */\n    log: {\n      _func: resolvedArgs => validNumber(Math.log(resolvedArgs[0]), 'log'),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Compute the base 10 logarithm of a number.\n     * @param {number} num A number greater than or equal to zero\n     * @return {number} The base 10 log result\n     * @function log10\n     * @example\n     * log10(100000) // 5\n     */\n    log10: {\n      _func: resolvedArgs => validNumber(Math.log10(resolvedArgs[0]), 'log10'),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Converts all the alphabetic code points in a string to lowercase.\n     * @param {string} input input string\n     * @returns {string} the lower case value of the input string\n     * @function lower\n     * @example\n     * lower(\"E. E. Cummings\") // returns e. e. cummings\n     */\n    lower: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toLowerCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Apply an expression to every element in an array and return the array of results.\n     * An input array of length N will return an array of length N.\n     * @param {array} elements array of elements to process\n     * @param {expression} expr expression to evaluate\n     * @return {array} the mapped array\n     * @function map\n     * @example\n     * map([1, 2, 3, 4], &(@ + 1)) // returns [2, 3, 4, 5]\n     * map([\"doe\", \"nick\", \"chris\"], &length(@)) // returns [3, 4, 5]\n     */\n    map: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        return resolvedArgs[0].map(arg => runtime.interpreter.visit(exprefNode, arg));\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    /**\n     * Calculates the largest value in the provided `collection` arguments.\n     * If all collections are empty, an evaluation error is thrown.\n     * `max()` can work on numbers or strings, but not a combination of numbers and strings.\n     * If all values are null, the result is 0.\n     * @param {...(number[]|string[]|number|string)} collection values/array(s) in which the maximum\n     * element is to be calculated\n     * @return {number|string} the largest value found\n     * @function max\n     * @example\n     * max([1, 2, 3], [4, 5, 6]) // returns 6\n     * max([\"a\", \"a1\", \"b\"]) // returns \"b\"\n     * max(8, 10, 12) // returns 12\n     */\n    max: {\n      _func: args => {\n        // flatten the args into a single array\n        const array = args.reduce((prev, cur) => prev.concat(cur), []);\n        if (array.length === 0) throw evaluationError('max() requires at least one argument');\n        const isNumber = a => getType(a) === TYPE_NUMBER;\n        const isString = a => getType(a) === TYPE_STRING;\n        if (!(array.every(isNumber) || array.every(isString))) {\n          throw typeError('max() requires all arguments to be of the same type');\n        }\n        return array\n          .sort((a, b) => (a > b ? 1 : -1))\n          .pop();\n      },\n      _signature: [{\n        types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING, TYPE_NUMBER, TYPE_STRING],\n        variadic: true,\n      }],\n    },\n\n    /**\n     * Accepts one or more objects, and returns a single object with\n     * all objects merged.\n     * The first object is copied, and then\n     * and each key value pair from each subsequent object\n     * are added to the first object.  Duplicate keys in subsequent objects will\n     * override those found in earlier objects.\n     * @param {...object} args\n     * @return {object} The combined object\n     * @function merge\n     * @example\n     * merge({a: 1, b: 2}, {c : 3, d: 4}) // returns {a :1, b: 2, c: 3, d: 4}\n     * merge({a: 1, b: 2}, {a : 3, d: 4}) // returns {a :3, b: 2, d: 4}\n     */\n    merge: {\n      _func: resolvedArgs => {\n        const merged = {};\n        resolvedArgs.forEach(current => {\n          if (current === null) return;\n          Object.entries(current || {}).forEach(([key, value]) => {\n            merged[key] = value;\n          });\n        });\n        return merged;\n      },\n      _signature: [{ types: [TYPE_OBJECT, TYPE_NULL], variadic: true }],\n    },\n\n    /**\n     * Extracts a substring from text, or a subset from an array.\n     * @param {string|array} subject the text string or array of elements from which to extract.\n     * @param {integer} startPos the zero-based position of the first code point\n     * or element to extract.\n     * @param {integer} length The number of code points or elements to return from the\n     * string or array.\n     * If greater then the length of `subject` the length of the subject is used.\n     * @return {string|array} The resulting substring or array subset of elements\n     * @function mid\n     * @example\n     * mid(\"Fluid Flow\", 0, 5) // returns \"Fluid\"\n     * mid(\"Fluid Flow\", 6, 20) // returns \"Flow\"\n     * mid(\"Fluid Flow\", 20, 5) // returns \"\"\n     * mid([0,1,2,3,4,5,6,7,8,9], 2, 3) // returns [2,3,4]\n     */\n    mid: {\n      _func: args => {\n        const startPos = toInteger(args[1]);\n        const numEntries = toInteger(args[2]);\n        if (startPos < 0) throw evaluationError('mid() requires a non-negative start position');\n        if (numEntries < 0) throw evaluationError('mid() requires a non-negative length parameter');\n        if (isArrayType(args[0])) {\n          return args[0].slice(startPos, startPos + numEntries);\n        }\n        const text = Array.from(toString(args[0]));\n        return text.slice(startPos, startPos + numEntries).join('');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Extract the milliseconds of the time value in a <<_date_and_time_values, date/time value>>.\n     * @param {number} date datetime/time for which the millisecond is to be returned.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} The number of milliseconds: 0 through 999\n     * @function millisecond\n     * @example\n     * millisecond(datetime(2008, 5, 23, 12, 10, 53, 42)) // returns 42\n     */\n    millisecond: {\n      _func: args => getDateObj(args[0]).getMilliseconds(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Calculates the smallest value in the input arguments.\n     * If all collections/values are empty, an evaluation error is thrown.\n     * `min()` can work on numbers or strings, but not a combination of numbers and strings.\n     * If all values are null, zero is returned.\n     * @param {...(number[]|string[]|number|string)} collection\n     * Values/arrays to search for the minimum value\n     * @return {number|string} the smallest value found\n     * @function min\n     * @example\n     * min([1, 2, 3], [4, 5, 6]) // returns 1\n     * min([\"a\", \"a1\", \"b\"]) // returns \"a\"\n      * min(8, 10, 12) // returns 8\n     */\n    min: {\n      _func: args => {\n        // flatten the args into a single array\n        const array = args.reduce((prev, cur) => prev.concat(cur), []);\n        if (array.length === 0) throw evaluationError('min() requires at least one argument');\n\n        const isNumber = a => getType(a) === TYPE_NUMBER;\n        const isString = a => getType(a) === TYPE_STRING;\n        if (!(array.every(isNumber) || array.every(isString))) {\n          throw typeError('max() requires all arguments to be of the same type');\n        }\n        return array\n          .sort((a, b) => (a < b ? 1 : -1))\n          .pop();\n      },\n      _signature: [{\n        types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING, TYPE_NUMBER, TYPE_STRING],\n        variadic: true,\n      }],\n    },\n\n    /**\n     * Extract the minute (0 through 59) from a <<_date_and_time_values, date/time value>>\n     * @param {number} date A datetime/time value.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} Number of minutes in the time portion of the date/time value\n     * @function minute\n     * @example\n     * minute(datetime(2008,5,23,12, 10, 0)) // returns 10\n     * minute(time(12, 10, 0)) // returns 10\n     */\n    minute: {\n      _func: args => getDateObj(args[0]).getMinutes(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Return the remainder when one number is divided by another number.\n     * @param {number} dividend The number for which to find the remainder.\n     * @param {number} divisor The number by which to divide number.\n     * @return {number} Computes the remainder of `dividend`/`divisor`.\n     * If `dividend` is negative, the result will also be negative.\n     * If `dividend` is zero, an error is thrown.\n     * @function mod\n     * @example\n     * mod(3, 2) // returns 1\n     * mod(-3, 2) // returns -1\n     */\n    mod: {\n      _func: args => {\n        const p1 = args[0];\n        const p2 = args[1];\n        const result = p1 % p2;\n        if (Number.isNaN(result)) throw evaluationError(`Bad parameter for mod: '${p1} % ${p2}'`);\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Finds the month of a date.\n     * @param {number} date source <<_date_and_time_values, date/time value>>.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} The month number value, ranging from 1 (January) to 12 (December).\n     * @function month\n     * @example\n     * month(datetime(2008,5,23)) // returns 5\n     */\n    month: {\n      // javascript months start from 0\n      _func: args => getDateObj(args[0]).getMonth() + 1,\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Compute logical NOT of a value. If the parameter is not boolean\n     * it will be <<_type_coercion_rules,cast to boolean>>\n     * Note the related <<_not_operator, unary NOT operator>>.\n     * @param {any} value - any data type\n     * @returns {boolean} The logical NOT applied to the input parameter\n     * @example\n     * not(length(\"bar\") > 0) // returns false\n     * not(false()) // returns true\n     * not(\"abcd\") // returns false\n     * not(\"\") // returns true\n     * @function not\n     */\n    not: {\n      _func: resolveArgs => !toBoolean(valueOf(resolveArgs[0])),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Finds the first argument that does not resolve to `null`.\n     * This function accepts one or more arguments, and will evaluate\n     * them in order until a non-null argument is encountered. If all\n     * arguments values resolve to null, then return a null value.\n     * @param {...any} argument\n     * @return {any}\n     * @function notNull\n     * @example\n     * notNull(1, 2, 3, 4, `null`) // returns 1\n     * notNull(`null`, 2, 3, 4, `null`) // returns 2\n     */\n    notNull: {\n      _func: resolvedArgs => {\n        const result = resolvedArgs.find(arg => getType(arg) !== TYPE_NULL);\n        return result === undefined ? null : result;\n      },\n      _signature: [{ types: [TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Retrieve the current date/time.\n     * @return {number} representation of the <<_date_and_time_values, current date/time value>>.\n     * @function now\n     */\n    now: {\n      _func: () => getDateNum(Date.now()),\n      _signature: [],\n    },\n\n    /**\n     * Return constant null value.\n     * Expressions may also use the JSON literal: `` `null` ``\n     * @returns {boolean} True\n     * @function null\n     */\n    null: {\n      _func: () => null,\n      _signature: [],\n    },\n\n    /**\n     * Determines the logical OR result of a set of parameters.\n     * If the parameters are not boolean they will be <<_type_coercion_rules,cast to\n     * boolean>>.\n     * Note the related <<_or_operator, Or Operator>>.\n     * @param {any} first logical expression\n     * @param {...any} [operand] any number of additional expressions\n     * @returns {boolean} The logical result of applying OR to all parameters\n     * @example\n     * or((x / 2) == y, (y * 2) == x) // true\n     * @function or\n     */\n    or: {\n      _func: resolvedArgs => {\n        let result = toBoolean(valueOf(resolvedArgs[0]));\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result || toBoolean(valueOf(arg));\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n\n    /**\n     * Computes `a` raised to a power `x`. (a^x)\n     * @param {number} a The base number -- can be any real number.\n     * @param {number} x The exponent to which the base number is raised.\n     * @return {number}\n     * @function power\n     * @example\n     * power(10, 2) // returns 100 (10 raised to power 2)\n     */\n    power: {\n      _func: args => validNumber(args[0] ** args[1], 'power'),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Apply proper casing to a string.  Proper casing is where the first letter of each\n     * word is converted to an\n     * uppercase letter and the rest of the letters in the word converted to lowercase.\n     * Words are demarcated by whitespace, punctuation, or numbers.\n     * Specifically, any character(s) matching the regular expression: `[\\s\\d\\p{P}]+`.\n     * @param {string} text source string\n     * @returns {string} source string with proper casing applied.\n     * @function proper\n     * @example\n     * proper(\"this is a TITLE\") // returns \"This Is A Title\"\n     * proper(\"2-way street\") // returns \"2-Way Street\"\n     * proper(\"76BudGet\") // returns \"76Budget\"\n     */\n    proper: {\n      _func: args => {\n        const capitalize = word => `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;\n        const original = toString(args[0]);\n        // split the string by whitespace, punctuation, and numbers\n        const wordParts = original.match(/[\\s\\d\\p{P}]+|[^\\s\\d\\p{P}]+/gu);\n        if (wordParts !== null) return wordParts.map(w => capitalize(w)).join('');\n        return capitalize(original);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Generate a pseudo random number.\n     * @returns {number} A value greater than or equal to zero, and less than one.\n     * @function random\n     * @example\n     * random() // 0.022585461160693265\n     */\n    random: {\n      _func: () => Math.random(),\n      _signature: [],\n    },\n    /**\n     * Executes a user-supplied reducer expression on each element of an\n     * array, in order, passing in the return value from the expression from the preceding element.\n     * The final result of running the reducer across all elements of the input array is a\n     * single value.\n     * The expression can access the following properties of the current object:\n     *\n     * * accumulated: accumulated value based on the previous expression.\n     * For the first array element use the `initialValue` parameter.  If not provided, then `null`\n     * * current: current element to process\n     * * index: index of the current element in the array\n     * * array: original array\n     * @param {array} elements array of elements on which the expression will be evaluated\n     * @param {expression} expr reducer expression to be executed on each element\n     * @param {any} initialValue the accumulated value to pass to the first array element\n     * @return {any}\n     * @function reduce\n     * @example\n     * reduce([1, 2, 3], &(accumulated + current)) // returns 6\n     * // find maximum entry by age\n     * reduce(\n     *   [{age: 10, name: \"Joe\"},{age: 20, name: \"John\"}],\n     *   &max(@.accumulated.age, @.current.age), @[0].age)\n     * reduce([3, 3, 3], &accumulated * current, 1) // returns 27\n     */\n    reduce: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        return resolvedArgs[0].reduce(\n          (accumulated, current, index, array) => runtime.interpreter.visit(exprefNode, {\n            accumulated, current, index, array,\n          }),\n          resolvedArgs.length === 3 ? resolvedArgs[2] : null,\n        );\n      },\n      _signature: [\n        { types: [TYPE_ARRAY] },\n        { types: [TYPE_EXPREF] },\n        { types: [TYPE_ANY], optional: true },\n      ],\n    },\n\n    /**\n     * Register a function.  The registered function may take one parameter.\n     * If more parameters are needed, combine them in an array or object.\n     * A function may not be re-registered with a different definition.\n     * Note that implementations are not required to provide `register()` in order to be conformant.\n     * Built-in functions may not be overridden.\n     * @param {string} functionName Name of the function to register.\n     * `functionName` must begin with an underscore and follow the regular\n     * expression pattern:\n     * `{caret}_{startsb}_a-zA-Z0-9${endsb}{asterisk}$`\n     * @param {expression} expr Expression to execute with this function call\n     * @return {{}} returns an empty object\n     * @function register\n     * @example\n     * register(\"_product\", &@[0] * @[1]) // can now call: _product([2,21]) => returns 42\n     * register(\"_ltrim\", &split(@,\"\").reduce(@, &accumulated & current | if(@ = \" \", \"\", @), \"\"))\n     * // _ltrim(\"  abc  \") => returns \"abc  \"\n     */\n    register: {\n      _func: resolvedArgs => {\n        const functionName = resolvedArgs[0];\n        const exprefNode = resolvedArgs[1];\n\n        if (!/^_[_a-zA-Z0-9$]*$/.test(functionName)) throw functionError(`Invalid function name: \"${functionName}\"`);\n        if (functionMap[functionName]\n          && functionMap[functionName]._exprefNode.value !== exprefNode.value) {\n          // custom functions can be re-registered as long as the expression is the same\n          throw functionError(`Cannot override function: \"${functionName}\" with a different definition`);\n        }\n        functionMap[functionName] = {\n          _func: args => runtime.interpreter.visit(exprefNode, ...args),\n          _signature: [{ types: [TYPE_ANY], optional: true }],\n          _exprefNode: exprefNode,\n        };\n        return {};\n      },\n      _signature: [\n        { types: [TYPE_STRING] },\n        { types: [TYPE_EXPREF] },\n      ],\n    },\n\n    /**\n     * Generates text (or an array) where we substitute elements at a given start position and\n     * length, with new text (or array elements).\n     * @param {string|array} subject original text or array\n     * @param {integer} start zero-based index in the original text\n     * from where to begin the replacement.  Must be greater than or equal to 0.\n     * @param {integer} length number of code points to be replaced.\n     * If `start` + `length` is greater than the length of `subject`,\n     * all text past `start` will be replaced.\n     * @param {any} replacement Replacement to insert at the start index.\n     * If `subject` is an array, and `replacement` is an array, the `replacement` array\n     * elements will be inserted into the `subject` array.\n     * If `subject` is an array and replacement is not an array, the `replacement` will be\n     * inserted as a single element in `subject`\n     * If `subject` is a string, the `replacement` will be coerced to a string.\n     * @returns {string|array} the resulting text or array\n     * @function replace\n     * @example\n     * replace(\"abcdefghijk\", 5, 5, \"*\") // returns abcde*k\n     * replace(\"2009\",2,2,\"10\") // returns  2010\n     * replace(\"123456\",0,3,\"@\") // returns @456\n     * replace([\"blue\",\"black\",\"white\",\"red\"], 1, 2, [\"green\"]) // returns [\"blue\",\"green\",\"red\"]\n     */\n    replace: {\n      _func: args => {\n        const startPos = toInteger(args[1]);\n        const numElements = toInteger(args[2]);\n        if (startPos < 0) throw evaluationError('replace() start position must be greater than or equal to 0');\n        if (numElements < 0) throw evaluationError('replace() length must be greater than or equal to 0');\n        if (isArrayType(args[0])) {\n          const sourceArray = valueOf(args[0]);\n          let replacement = valueOf(args[3]);\n          if (!isArrayType(replacement)) replacement = [replacement];\n          sourceArray.splice(startPos, numElements, ...replacement);\n          return sourceArray;\n        }\n        const subject = Array.from(toString(args[0]));\n        if (isArrayType(args[3]) || getType(args[3]) === TYPE_OBJECT) throw typeError('replace() replacement must not be an array or object');\n        const newText = toString(args[3]);\n\n        subject.splice(startPos, numElements, newText);\n        return subject.join('');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_ANY] },\n      ],\n    },\n\n    /**\n     * Return text repeated `count` times.\n     * @param {string} text text to repeat\n     * @param {integer} count number of times to repeat the text.\n     * Must be greater than or equal to 0.\n     * @returns {string} Text generated from the repeated text.\n     * if `count` is zero, returns an empty string.\n     * @function rept\n     * @example\n     * rept(\"x\", 5) // returns \"xxxxx\"\n     */\n    rept: {\n      _func: args => {\n        const text = toString(args[0]);\n        const count = toInteger(args[1]);\n        if (count < 0) throw evaluationError('rept() count must be greater than or equal to 0');\n        return text.repeat(count);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Reverses the order of an array or the order of code points in a string\n     * @param {string|array} subject the source to be reversed\n     * @return {array} The resulting reversed array or string\n     * @function reverse\n     * @example\n     * reverse([\"a\", \"b\", \"c\"]) // returns [\"c\", \"b\", \"a\"]\n     */\n    reverse: {\n      _func: resolvedArgs => {\n        const originalStr = valueOf(resolvedArgs[0]);\n        const typeName = getType(originalStr);\n        if (typeName === TYPE_STRING) {\n          return Array.from(originalStr).reverse().join('');\n        }\n        const reversedArray = resolvedArgs[0].slice(0);\n        return reversedArray.reverse();\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],\n    },\n\n    /**\n     * Generates a string from the right-most code points of a string or\n     * a subset of elements from the end of an array\n     * @param {string|array} subject The text/array containing the code points/elements to extract\n     * @param {integer} [elements=1] number of elements to pick\n     * @return {string|array} The extracted substring or array subset\n     * Returns null if the number of elements is less than 0\n     * @function right\n     * @example\n     * right(\"Sale Price\", 4) // returns \"rice\"\n     * right(\"Sweden\") // returns \"n\"\n     * right([4, 5, 6], 2) // returns [5, 6]\n     */\n    right: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toInteger(args[1]) : 1;\n        if (numEntries < 0) throw evaluationError('right() count must be greater than or equal to 0');\n        if (args[0] instanceof Array) {\n          if (numEntries === 0) return [];\n          return args[0].slice(numEntries * -1);\n        }\n        if (numEntries === 0) return '';\n        const text = Array.from(toString(args[0]));\n        return text.slice(numEntries * -1).join('');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Round a number to a specified precision:\n     *\n     * * If `precision` is greater than zero, round to the specified number of decimal places.\n     * * If `precision` is 0, round to the nearest integer.\n     * * If `precision` is less than 0, round to the left of the decimal point.\n     * @param {number} num number to round\n     * @param {integer} [precision=0] precision to use for the rounding operation.\n     * @returns {number} rounded value. Rounding a half value will round up.\n     * @function round\n     * @example\n     * round(2.15, 1) // returns 2.2\n     * round(626.3,-3) // returns 1000 (Rounds 626.3 to the nearest multiple of 1000)\n     * round(626.3, 0) // returns 626\n     * round(1.98,-1) // returns 0 (Rounds 1.98 to the nearest multiple of 10)\n     * round(-50.55,-2) // -100 (round -50.55 to the nearest multiple of 100)\n     * round(1.95583) // 2\n     * round(-1.5) // -1\n     */\n    round: {\n      _func: args => round(args[0], args.length > 1 ? toInteger(args[1]) : 0),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Perform a wildcard search.  The search is case-sensitive and supports two forms of wildcards:\n     * `{asterisk}` finds a sequence of code points and `?` finds a single code point.\n     * To use `{asterisk}` or `?` or `{backslash}` as text values,\n     * precede them with an escape (`{backslash}`) character.\n     * Note that the wildcard search is not greedy.\n     * e.g. `search(\"a{asterisk}b\", \"abb\")` will return `[0, \"ab\"]` Not `[0, \"abb\"]`\n     * @param {string} findText the search string -- which may include wild cards.\n     * @param {string} withinText The string to search.\n     * @param {integer} [startPos=0] The zero-based position of withinText to start searching.\n     * A negative value is not allowed.\n     * @returns {array} returns an array with two values:\n     *\n     * * The start position of the found text and the text string that was found.\n     * * If a match was not found, an empty array is returned.\n     * @function search\n     * @example\n     * search(\"a?c\", \"acabc\") // returns [2, \"abc\"]\n     */\n    search: {\n      _func: args => {\n        const findText = toString(args[0]);\n        const withinText = toString(args[1]);\n        const startPos = args.length > 2 ? toInteger(args[2]) : 0;\n        if (startPos < 0) throw functionError('search() startPos must be greater than or equal to 0');\n        if (findText === null || withinText === null || withinText.length === 0) return [];\n\n        // Process as an array of code points\n        // Find escapes and wildcards\n        const globString = Array.from(findText).reduce((acc, cur) => {\n          if (acc.escape) return { escape: false, result: acc.result.concat(cur) };\n          if (cur === '\\\\') return { escape: true, result: acc.result };\n          if (cur === '?') return { escape: false, result: acc.result.concat('dot') };\n          if (cur === '*') {\n            // consecutive * are treated as a single *\n            if (acc.result.slice(-1).pop() === 'star') return acc;\n            return { escape: false, result: acc.result.concat('star') };\n          }\n          return { escape: false, result: acc.result.concat(cur) };\n        }, { escape: false, result: [] }).result;\n\n        const testMatch = (array, glob, match) => {\n          // we've consumed the entire glob, so we're done\n          if (glob.length === 0) return match;\n          // we've consumed the entire array, but there's still glob left -- no match\n          if (array.length === 0) return null;\n          const testChar = array[0];\n          let [globChar, ...nextGlob] = glob;\n          const isStar = globChar === 'star';\n          if (isStar) {\n            // '*' is at the end of the match -- so we're done matching\n            if (glob.length === 1) return match;\n            // we'll check for a match past the * and if not found, we'll process the *\n            [globChar, ...nextGlob] = glob.slice(1);\n          }\n          if (testChar === globChar || globChar === 'dot') {\n            return testMatch(array.slice(1), nextGlob, match.concat(testChar));\n          }\n          // no match, so consume wildcard *\n          if (isStar) return testMatch(array.slice(1), glob, match.concat(testChar));\n\n          return null;\n        };\n        // process code points\n        const within = Array.from(withinText);\n        for (let i = startPos; i < within.length; i += 1) {\n          const result = testMatch(within.slice(i), globString, []);\n          if (result !== null) return [i, result.join('')];\n        }\n        return [];\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n\n    },\n\n    /**\n     * Extract the seconds of the time value in a <<_date_and_time_values, date/time value>>.\n     * @param {number} date datetime/time for which the second is to be returned.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} The number of seconds: 0 through 59\n     * @function second\n     * @example\n     * second(datetime(2008,5,23,12, 10, 53)) // returns 53\n     * second(time(12, 10, 53)) // returns 53\n     */\n    second: {\n      _func: args => getDateObj(args[0]).getSeconds(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Computes the sign of a number passed as argument.\n     * @param {number} num any number\n     * @return {number} returns 1 or -1, indicating the sign of `num`.\n     * If the `num` is 0, it will return 0.\n     * @function sign\n     * @example\n     * sign(5) // 1\n     * sign(-5) // -1\n     * sign(0) // 0\n     */\n    sign: {\n      _func: resolvedArgs => Math.sign(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Computes the sine of a number in radians\n     * @param {number} angle A number representing an angle in radians.\n     * @return {number} The sine of `angle`, between -1 and 1, inclusive\n     * @function sin\n     * @example\n     * sin(0) // 0\n     * sin(1) // 0.8414709848078965\n     */\n    sin: {\n      _func: resolvedArgs => Math.sin(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * This function accepts an array of strings or numbers and returns an\n     * array with the elements in sorted order.\n     * String sorting is based on code points and is not locale-sensitive.\n     * @param {number[]|string[]} list to be sorted\n     * @return {number[]|string[]} The ordered result\n     * @function sort\n     * @example\n     * sort([1, 2, 4, 3, 1]) // returns [1, 1, 2, 3, 4]\n     */\n    sort: {\n      _func: resolvedArgs => {\n        const array = resolvedArgs[0].slice();\n        if (array.length === 0) return [];\n        // JavaScript default sort converts numbers to strings\n        if (getType(array[0]) === TYPE_STRING) return array.sort();\n\n        return array.sort((a, b) => {\n          if (a < b) return -1;\n          if (a > b) return 1;\n          return 0;\n        });\n      },\n      _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],\n    },\n\n    /**\n     * Sort an array using an expression to find the sort key. For each element\n     * in the array, the expression is applied and the resulting\n     * value is used as the sort value. If the result of\n     * evaluating the expression against the current array element results in type\n     * other than a number or a string, a <<_errors, TypeError>> will occur.\n     * @param {array} elements Array to be sorted\n     * @param {expression} expr The comparison expression\n     * @return {array} The sorted array\n     * @function sortBy\n     * @example\n     * // returns [\"e\", \"def\", \"abcd\"]\n     * sortBy([\"abcd\", \"e\", \"def\"], &length(@))\n     *\n     * // returns [{year: 1910}, {year: 2010}, {year: 2020}]\n     * sortBy([{year: 2010}, {year: 2020}, {year: 1910}], &year)\n     *\n     * // returns [5, -10, -11, -15, 30]\n     * sortBy([-15, 30, -10, -11, 5], &abs(@))\n     */\n    sortBy: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n          return sortedArray;\n        }\n        const exprefNode = resolvedArgs[1];\n        const requiredType = getType(\n          runtime.interpreter.visit(exprefNode, sortedArray[0]),\n        );\n        if (![TYPE_NUMBER, TYPE_STRING].includes(requiredType)) {\n          throw typeError('Bad data type for sortBy()');\n        }\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        const decorated = [];\n        for (let i = 0; i < sortedArray.length; i += 1) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort((a, b) => {\n          const exprA = runtime.interpreter.visit(exprefNode, a[1]);\n          const typeA = getType(exprA);\n          const exprB = runtime.interpreter.visit(exprefNode, b[1]);\n          const typeB = getType(exprB);\n          if (typeA !== requiredType) {\n            throw typeError(`sortBy expected ${typeNameTable[requiredType]}, received ${typeNameTable[typeA]}`);\n          } else if (typeB !== requiredType) {\n            throw typeError(`sortyBy expected ${typeNameTable[requiredType]}, received ${typeNameTable[typeB]}`);\n          }\n          if (exprA > exprB) return 1;\n          if (exprA < exprB) return -1;\n          // If they\"re equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        });\n        // Undecorate: extract out the original list elements.\n        for (let j = 0; j < decorated.length; j += 1) {\n          [, sortedArray[j]] = decorated[j];\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    /**\n     * Split a string into an array, given a separator\n     * @param {string} string string to split\n     * @param {string} separator separator where the split(s) should occur\n     * @return {string[]} The array of separated strings\n     * @function split\n     * @example\n     * split(\"abcdef\", \"\") // returns [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n     * split(\"abcdef\", \"e\") // returns [\"abcd\", \"f\"]\n     */\n    split: {\n      _func: args => {\n        const str = toString(args[0]);\n        const separator = toString(args[1]);\n        // for empty separator, return an array of code points\n        return separator.length === 0 ? Array.from(str) : str.split(separator);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n         * Find the square root of a number\n         * @param {number} num source number\n         * @return {number} The calculated square root value\n         * @function sqrt\n         * @example\n         * sqrt(4) // returns 2\n         */\n    sqrt: {\n      _func: args => {\n        const result = Math.sqrt(args[0]);\n        return validNumber(result, 'sqrt');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Determine if a string starts with a prefix.\n     * @param {string} subject string to search\n     * @param {string} prefix prefix to search for\n     * @return {boolean} true if `prefix` matches the start of `subject`\n     * @function startsWith\n     * @example\n     * startsWith(\"jack is at home\", \"jack\") // returns true\n     */\n    startsWith: {\n      _func: resolvedArgs => {\n        const subject = Array.from(toString(resolvedArgs[0]));\n        const prefix = Array.from(toString(resolvedArgs[1]));\n        if (prefix.length > subject.length) return false;\n        for (let i = 0; i < prefix.length; i += 1) {\n          if (prefix[i] !== subject[i]) return false;\n        }\n        return true;\n      },\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n    /**\n     * Estimates standard deviation based on a sample.\n     * `stdev` assumes that its arguments are a sample of the entire population.\n     * If your data represents a entire population,\n     * then compute the standard deviation using [stdevp]{@link stdevp}.\n     * @param {number[]} numbers The array of numbers comprising the population.\n     * Array size must be greater than 1.\n     * @returns {number} [Standard deviation](https://en.wikipedia.org/wiki/Standard_deviation)\n     * @function stdev\n     * @example\n     * stdev([1345, 1301, 1368]) // returns 34.044089061098404\n     * stdevp([1345, 1301, 1368]) // returns 27.797\n     */\n    stdev: {\n      _func: args => {\n        const values = args[0];\n        if (values.length <= 1) throw evaluationError('stdev() must have at least two values');\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\n        const sumSquare = values.reduce((a, b) => a + b * b, 0);\n        const result = Math.sqrt((sumSquare - values.length * mean * mean) / (values.length - 1));\n        return validNumber(result, 'stdev');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n\n    /**\n     * Calculates standard deviation based on the entire population given as arguments.\n     * `stdevp` assumes that its arguments are the entire population.\n     * If your data represents a sample of the population,\n     * then compute the standard deviation using [stdev]{@link stdev}.\n     * @param {number[]} numbers The array of numbers comprising the population.\n     * An empty array is not allowed.\n     * @returns {number} Calculated standard deviation\n     * @function stdevp\n     * @example\n     * stdevp([1345, 1301, 1368]) // returns 27.797\n     * stdev([1345, 1301, 1368]) // returns 34.044\n     */\n    stdevp: {\n      _func: args => {\n        const values = args[0];\n        if (values.length === 0) throw evaluationError('stdevp() must have at least one value');\n\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\n        const meanSumSquare = values.reduce((a, b) => a + b * b, 0) / values.length;\n        const result = Math.sqrt(meanSumSquare - mean * mean);\n        return validNumber(result, 'stdevp');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n\n    /**\n     * Generates a string from the input `text`,\n     * with text `old` replaced by text `new` (when searching from the left).\n     * If there is no match, or if `old` has length 0, `text` is returned unchanged.\n     * Note that `old` and `new` may have different lengths.\n     * @param {string} text The text for which to substitute code points.\n     * @param {string} old The text to replace.\n     * @param {string} new The text to replace `old` with.  If `new` is an empty string, then\n     * occurrences of `old` are removed from `text`.\n     * @param {integer} [which] The zero-based occurrence of `old` text to replace with `new` text.\n     * If `which` parameter is omitted, every occurrence of `old` is replaced with `new`.\n     * @returns {string} replaced string\n     * @function substitute\n     * @example\n     * substitute(\"Sales Data\", \"Sales\", \"Cost\") // returns \"Cost Data\"\n     * substitute(\"Quarter 1, 2001\", \"1\", \"2\", 1)\" // returns \"Quarter 1, 2002\"\n     * substitute(\"Quarter 1, 2011\", \"1\", \"2\", 2)\" // returns \"Quarter 1, 2012\"\n     */\n    substitute: {\n      _func: args => {\n        const src = Array.from(toString(args[0]));\n        const old = Array.from(toString(args[1]));\n        const replacement = Array.from(toString(args[2]));\n\n        if (old.length === 0) return args[0];\n\n        // no third parameter? replace all instances\n        let replaceAll = true;\n        let whch = 0;\n        if (args.length > 3) {\n          replaceAll = false;\n          whch = toInteger(args[3]);\n          if (whch < 0) throw evaluationError('substitute() which parameter must be greater than or equal to 0');\n          whch += 1;\n        }\n\n        let found = 0;\n        const result = [];\n        // find the instances to replace\n        for (let j = 0; j < src.length;) {\n          const match = old.every((c, i) => src[j + i] === c);\n          if (match) found += 1;\n          if (match && (replaceAll || found === whch)) {\n            result.push(...replacement);\n            j += old.length;\n          } else {\n            result.push(src[j]);\n            j += 1;\n          }\n        }\n        return result.join('');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Calculates the sum of the provided array.\n     * An empty array will produce a return value of 0.\n     * @param {number[]} collection array of numbers\n     * @return {number} The computed sum\n     * @function sum\n     * @example\n     * sum([1, 2, 3]) // returns 6\n     */\n    sum: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        resolvedArgs[0].forEach(arg => {\n          sum += arg * 1;\n        });\n        return sum;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n    /**\n     * Computes the tangent of a number in radians\n     * @param {number} angle A number representing an angle in radians.\n     * @return {number} The tangent of `angle`\n     * @function tan\n     * @example\n     * tan(0) // 0\n     * tan(1) // 1.5574077246549023\n     */\n    tan: {\n      _func: resolvedArgs => Math.tan(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    /**\n     * Construct and returns a <<_date_and_time_values, time value>>.\n     * If any of the units are greater or less than their normal range,\n     * the overflow/underflow will be added/subtracted from the next greater unit.\n     * @param {integer} hours Zero-based integer value between 0 and 23 representing\n     * the hour of the day.\n     * @param {integer} [minutes=0] Zero-based integer value representing\n     * the minute segment of a time.\n     * @param {integer} [seconds=0] Zero-based integer value representing the seconds\n     * segment of a time.\n     * @return {number} Returns a date/time value representing the fraction\n     * of the day consumed by the given time\n     * @function time\n     * @example\n     * time(12, 0, 0) | [hour(@), minute(@), second(@)] // returns [12, 0, 0]\n     */\n    time: {\n      _func: args => {\n        const hours = toInteger(args[0]);\n        const minutes = args.length > 1 ? toInteger(args[1]) : 0;\n        const seconds = args.length > 2 ? toInteger(args[2]) : 0;\n        // Since time values are interchangeable with date and datetime values, it\"s consistent\n        // to create them at the epoch\n        const epochTime = new Date(1970, 0, 1, hours, minutes, seconds);\n        return getDateNum(epochTime);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Converts the provided argument to an array.\n     * The conversion happens as per the following rules:\n     *\n     * * array - Returns the provided value.\n     * * number/string/object/boolean/null - Returns a one element array containing the argument.\n     * @param {any} arg parameter to turn into an array\n     * @return {array} The resulting array\n     * @function toArray\n     * @example\n     * toArray(1) // returns [1]\n     * toArray(null()) // returns [`null`]\n     */\n    toArray: {\n      _func: resolvedArgs => (isArrayType(resolvedArgs[0]) ? resolvedArgs[0] : [resolvedArgs[0]]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    /**\n     * Converts the provided string to a date/time value.\n     *\n     * @param {string} ISOString An [ISO8601 formatted string]{@link https://www.iso.org/iso-8601-date-and-time-format.html}.\n     * (limited to the [RFC 3339]{@link https://www.rfc-editor.org/rfc/rfc3339} profile)\n     * If the string does not include a timezone offset (or trailing 'Z'),\n     * it will be assumed to be local time\n     * @return {number} The resulting <<_date_and_time_values, date/time number>>.\n     * If conversion fails, return null.\n     * @function toDate\n     * @example\n     * toDate(\"20231110T130000+04:00\") // returns 19671.375\n     * toDate(\"2023-11-10T13:00:00+04:00\") // returns 19671.375\n     * toDate(\"20231110\") | year(@) & \"/\" & month(@) // returns \"2023/11\"\n     */\n    toDate: {\n      _func: resolvedArgs => {\n        // expand compact notation so that the Date() constructor will\n        // accept the value\n        const iso = toString(resolvedArgs[0])\n          .replace(/(\\d\\d\\d\\d)(\\d\\d)(\\d\\d)/, '$1-$2-$3')\n          .replace(/T(\\d\\d)(\\d\\d)(\\d\\d)/, 'T$1:$2:$3');\n        const dateparts = iso.split(/[\\D,zZ]+/);\n        let d;\n        if (dateparts.length <= 3) {\n          if (dateparts.length < 3 || dateparts.find(x => x === '') === '') {\n            debug.push(`Failed to convert \"${resolvedArgs[0]}\" to a date`);\n            return null;\n          }\n        }\n        if (dateparts.length < 7) {\n          // no timezone component, so assume local time\n          // The date constructor always parses an ISO string as\n          // UTC -- with or without a trailing 'z'\n          // But if there's no timezone component, it needs to be local time\n\n          const range = [99999, 12, 31, 23, 59, 59, 999];\n          // check that the date parts are in range\n          for (let i = 0; i < dateparts.length; i += 1) {\n            if (dateparts[i] > range[i]) {\n              debug.push(`Failed to convert \"${resolvedArgs[0]}\" to a date`);\n              return null;\n            }\n          }\n          // account for zero-based date month parts\n          d = new Date(...dateparts.map((x, i) => (i === 1 ? x - 1 : x * 1)));\n        } else {\n          d = new Date(iso);\n        }\n        if (d instanceof Date && Number.isFinite(d.getTime())) return getDateNum(d);\n        debug.push(`Failed to convert \"${resolvedArgs[0]}\" to a date`);\n\n        return null;\n      },\n      _signature: [{ types: [TYPE_STRING] }],\n    },\n\n    /**\n     * Returns a <<_date_and_time_values, date/time>> value representing\n     * the start of the current day. i.e. midnight\n     * @return {number} today at midnight\n     * @function today\n     */\n    today: {\n      _func: () => {\n        const now = new Date(Date.now());\n        // We used to take the floor() to truncate h/m/s from Date.now(), but that would return\n        // today at UTC time.  We want today in local time.\n        // i.e. UTC time could be a day ahead or behind\n        // But note that means that the result is not an integer.\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        return getDateNum(today);\n      },\n      _signature: [],\n    },\n\n    /**\n     * Converts the provided arg to a number as per\n     * the <<_type_coercion_rules,type coercion rules>>.\n     *\n     * @param {any} arg to convert to number\n     * @param {integer} [base=10] If the input `arg` is a string, the use base to convert to number.\n     * One of: 2, 8, 10, 16. Defaults to 10.\n     * @return {number} The resulting number.  If conversion to number fails, return null.\n     * @function toNumber\n     * @example\n     * toNumber(1) // returns 1\n     * toNumber(\"10\") // returns 10\n     * toNumber({a: 1}) // returns null\n     * toNumber(true()) // returns 1\n     * toNumber(\"10f\") // returns null\n     * toNumber(\"FF\", 16) // returns 255\n     */\n    toNumber: {\n      _func: resolvedArgs => {\n        const num = valueOf(resolvedArgs[0]);\n        const base = resolvedArgs.length > 1 ? toInteger(resolvedArgs[1]) : 10;\n        if (getType(num) === TYPE_STRING && base !== 10) {\n          let digitCheck;\n          if (base === 2) digitCheck = /^[01.]+$/;\n          else if (base === 8) digitCheck = /^[0-7.]+$/;\n          else if (base === 16) digitCheck = /^[0-9A-Fa-f.]+$/;\n          else throw evaluationError(`Invalid base: \"${base}\" for toNumber()`);\n\n          if (num === '') return 0;\n          if (!digitCheck.test(num)) {\n            debug.push(`Failed to convert \"${num}\" base \"${base}\" to number`);\n            return null;\n          }\n          const parts = num.split('.');\n\n          let decimal = 0;\n          if (parts.length > 1) {\n            decimal = parseInt(parts[1], base) * base ** -parts[1].length;\n          }\n\n          const result = parseInt(parts[0], base) + decimal;\n          if (parts.length > 2 || Number.isNaN(result)) {\n            debug.push(`Failed to convert \"${num}\" base \"${base}\" to number`);\n            return null;\n          }\n          return result;\n        }\n        try {\n          return toNumber(num);\n        } catch (e) {\n          debug.push(`Failed to convert \"${num}\" to number`);\n          return null;\n        }\n      },\n      _signature: [\n        { types: [TYPE_ANY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Returns the argument converted to a string.\n     * If the argument is a string, it will be returned unchanged.\n     * Otherwise, returns the JSON encoded value of the argument.\n     * @param {any} arg Value to be converted to a string\n     * @param {integer} [indent=0] Indentation to use when converting\n     * objects and arrays to a JSON string\n     * @return {string} The result string.\n     * @function toString\n     * @example\n     * toString(1) // returns \"1\"\n     * toString(true()) // returns \"true\"\n     * toString({sum: 12 + 13}) // \"{\"sum\":25}\"\n     * toString(\"hello\") // returns \"hello\"\n     */\n    toString: {\n      _func: resolvedArgs => toJSON(resolvedArgs[0], resolvedArgs.length > 1 ? resolvedArgs[1] : 0),\n      _signature: [{ types: [TYPE_ANY] }, { types: [TYPE_NUMBER], optional: true }],\n    },\n\n    /**\n     * Remove leading and trailing spaces (U+0020), and replace all internal multiple spaces\n     * with a single space.  Note that other whitespace characters are left intact.\n     * @param {string} text string to trim\n     * @return {string} trimmed string\n     * @function trim\n     * @example\n     * trim(\"   ab    c   \") // returns \"ab c\"\n     */\n    trim: {\n      _func: args => {\n        const text = toString(args[0]);\n        // only removes the space character\n        // other whitespace characters like \\t \\n left intact\n        return text.split(' ').filter(x => x).join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Return constant boolean true value.\n     * Expressions may also use the JSON literal: `` `true` ``\n     * @returns {boolean} True\n     * @function true\n     */\n    true: {\n      _func: () => true,\n      _signature: [],\n    },\n\n    /**\n         * Truncates a number to an integer by removing the fractional part of the number.\n         * i.e. it rounds towards zero.\n         * @param {number} numA number to truncate\n         * @param {integer} [numB=0] A number specifying the number of decimal digits to preserve.\n         * @return {number} Truncated value\n         * @function trunc\n         * @example\n         * trunc(8.9) // returns 8\n         * trunc(-8.9) // returns -8\n         * trunc(8.912, 2) // returns 8.91\n         */\n    trunc: {\n      _func: args => {\n        const number = args[0];\n        const digits = args.length > 1 ? toInteger(args[1]) : 0;\n        const method = number >= 0 ? Math.floor : Math.ceil;\n        return method(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Finds the type name of the given `subject` argument as a string value.\n     * The return value will be one of the following:\n     *\n     * * number\n     * * string\n     * * boolean\n     * * array\n     * * object\n     * * null\n     * @param {any} subject type to evaluate\n     * @return {string} The type name\n     *\n     * @function type\n     * @example\n     * type(1) // returns \"number\"\n     * type(\"\") // returns \"string\"\n     */\n    type: {\n      _func: resolvedArgs => ({\n        [TYPE_NUMBER]: 'number',\n        [TYPE_STRING]: 'string',\n        [TYPE_ARRAY]: 'array',\n        [TYPE_ARRAY_NUMBER]: 'array',\n        [TYPE_ARRAY_STRING]: 'array',\n        [TYPE_ARRAY_ARRAY]: 'array',\n        [TYPE_OBJECT]: 'object',\n        [TYPE_BOOLEAN]: 'boolean',\n        [TYPE_EXPREF]: 'expref',\n        [TYPE_NULL]: 'null',\n      }[getType(resolvedArgs[0])]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    /**\n     * Find the set of unique elements within an array\n     * @param {array} input input array\n     * @return {array} array with duplicate elements removed\n     * @function unique\n     * @example\n     * unique([1, 2, 3, 4, 1, 1, 2]) // returns [1, 2, 3, 4]\n     */\n    unique: {\n      _func: args => {\n        // create an array of values for searching.  That way if the array elements are\n        // represented by class objects with a valueOf(), we'll locate them in the valueArray\n        // but return the original class object.\n        const valueArray = args[0].map(a => valueOf(a));\n        return args[0]\n          .filter(\n            (v, index) => valueArray.findIndex(\n              lookup => strictDeepEqual(lookup, valueOf(v)),\n            ) === index,\n          );\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY] },\n      ],\n    },\n\n    /**\n     * Converts all the alphabetic code points in a string to uppercase.\n     * @param {string} input input string\n     * @returns {string} the upper case value of the input string\n     * @function upper\n     * @example\n     * upper(\"abcd\") // returns \"ABCD\"\n     */\n    upper: {\n      _func: args => toString(args[0]).toUpperCase(),\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n\n    /**\n     * Perform an indexed lookup on an object or array\n     * @param {object | array | null} subject on which to perform the lookup\n     * @param {string | integer} index if `subject` is an object, `index` must be a string\n     * indicating the key name to search for.\n     * If `subject` is an array, then index must be an integer indicating the offset into the array\n     * @returns {any} the result of the lookup -- or `null` if not found.\n     * @function value\n     * @example\n     * value({a: 1, b:2, c:3}, \"a\") // returns 1\n     * value([1, 2, 3, 4], 2) // returns 3\n     */\n    value: {\n      _func: args => {\n        const indexType = getType(args[1]);\n        let index = args[1];\n        const subjectArray = isArrayType(args[0]);\n        // if the object/array has a getter for this property then don't validate types\n        // just return the value.\n        if (args[0] !== null && Object.getOwnPropertyDescriptor(args[0], index)?.get) {\n          return getProperty(args[0], index);\n        }\n        const obj = valueOf(args[0]);\n        if (obj === null) return null;\n        if (!(getType(obj) === dataTypes.TYPE_OBJECT || subjectArray)) {\n          throw typeError('First parameter to value() must be one of: object, array, null.');\n        }\n        if (subjectArray) {\n          if (indexType !== TYPE_NUMBER) throw typeError('value() requires an integer index for arrays');\n          index = toInteger(index);\n        } else if (indexType !== TYPE_STRING) {\n          throw typeError('value() requires a string index for objects');\n        }\n        const result = getProperty(args[0], index);\n        if (result === undefined) {\n          if (subjectArray) {\n            debug.push(\n              `Index: ${index} out of range for array size: ${obj.length}`,\n            );\n          } else debugAvailable(debug, obj, index);\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Generates an array of the values of the provided object.\n     * Note that because JSON objects are\n     * inherently unordered, the values associated with the provided object are\n     * also unordered.\n     * @param {object} obj source object\n     * @return {array} array of the values\n     * @function values\n     * @example\n     * values({a : 3, b : 4}) // returns [3, 4]\n     */\n    values: {\n      _func: resolvedArgs => Object.values(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_OBJECT] }],\n    },\n\n    /**\n     * Extract the day of the week from a date.\n     * The specific numbering of the day of week is controlled by the `returnType` parameter:\n     *\n     * * 1 : Sunday (1), Monday (2), ..., Saturday (7)\n     * * 2 : Monday (1), Tuesday (2), ..., Sunday(7)\n     * * 3 : Monday (0), Tuesday (1), ...., Sunday(6)\n     * @param {number} date <<_date_and_time_values, date/time value>> for\n     * which the day of the week is to be returned.\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @param {integer} [returnType=1] Determines the\n     * representation of the result.\n     * An unrecognized returnType will result in a error.\n     * @returns {integer} day of the week\n     * @function weekday\n     * @example\n     * weekday(datetime(2006,5,21)) // 1\n     * weekday(datetime(2006,5,21), 2) // 7\n     * weekday(datetime(2006,5,21), 3) // 6\n     */\n    weekday: {\n      _func: args => {\n        const date = args[0];\n        const type = args.length > 1 ? toInteger(args[1]) : 1;\n        const jsDate = getDateObj(date);\n        const day = jsDate.getDay();\n        // day is in range [0-7) with 0 mapping to sunday\n        switch (type) {\n          case 1:\n            // range = [1, 7], sunday = 1\n            return day + 1;\n          case 2:\n            // range = [1, 7] sunday = 7\n            return ((day + 6) % 7) + 1;\n          case 3:\n            // range = [0, 6] sunday = 6\n            return (day + 6) % 7;\n          default:\n            throw functionError(`Unsupported returnType: \"${type}\" for weekday()`);\n        }\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n\n    /**\n     * Finds the year of a datetime value\n     * @param {number} date input <<_date_and_time_values, date/time value>>\n     * Date/time values can be generated using the\n     * [datetime]{@link datetime}, [toDate]{@link todate}, [today]{@link today}, [now]{@link now}\n     * and [time]{@link time} functions.\n     * @return {integer} The year value\n     * @function year\n     * @example\n     * year(datetime(2008,5,23)) // returns 2008\n     */\n    year: {\n      _func: args => getDateObj(args[0]).getFullYear(),\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n\n    /**\n     * Generates a convolved (zipped) array containing grouped arrays of values from\n     * the array arguments from index 0, 1, 2, etc.\n     * This function accepts a variable number of arguments.\n     * The length of the returned array is equal to the length of the shortest array.\n     * @param {...array} arrays array of arrays to zip together\n     * @return {array} An array of arrays with elements zipped together\n     * @function zip\n     * @example\n     * zip([1, 2, 3], [4, 5, 6, 7]) // returns [[1, 4], [2, 5], [3, 6]]\n     */\n    zip: {\n      _func: args => {\n        const count = args.reduce((min, current) => Math.min(min, current.length), args[0].length);\n        const result = new Array(count);\n        for (let i = 0; i < count; i += 1) {\n          result[i] = [];\n          args.forEach(a => {\n            result[i].push(a[i]);\n          });\n        }\n        return result;\n      },\n      _signature: [{ types: [TYPE_ARRAY], variadic: true }],\n    },\n  };\n  return functionMap;\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable max-classes-per-file */\n/* eslint-disable no-underscore-dangle */\nimport TreeInterpreter from './TreeInterpreter.js';\nimport Parser from './Parser.js';\nimport { dataTypes } from './dataTypes.js';\nimport { matchType, getType, isArrayType } from './matchType.js';\nimport functions from './functions.js';\nimport {\n  isObject, strictDeepEqual, getValueOf,\n} from './utils.js';\nimport {\n  evaluationError, typeError, functionError,\n} from './errors.js';\n\n// Type constants used to define functions.\nconst { TYPE_OBJECT } = dataTypes;\n\nfunction getToNumber(stringToNumber) {\n  return value => {\n    const n = getValueOf(value); // in case it's an object that implements valueOf()\n    if (n === null) return 0;\n    if (n instanceof Array) {\n      throw typeError('Failed to convert array to number');\n    }\n    const type = typeof n;\n    if (type === 'number') return n;\n    if (type === 'string') return stringToNumber(n);\n    if (type === 'boolean') return n ? 1 : 0;\n    throw typeError('Failed to convert object to number');\n  };\n}\nfunction toString(a) {\n  if (a === null || a === undefined) return '';\n  const type = getType(a);\n  if (isArrayType(type)) {\n    throw typeError('Failed to convert array to string');\n  }\n  if (type === TYPE_OBJECT) {\n    throw typeError('Failed to convert object to string');\n  }\n  return a.toString();\n}\n\nconst defaultStringToNumber = (str => {\n  const n = +str;\n  return Number.isNaN(n) ? 0 : n;\n});\n\nclass Runtime {\n  constructor(debug, toNumber, customFunctions = {}) {\n    this.strictDeepEqual = strictDeepEqual;\n    this.toNumber = toNumber;\n    this.functionTable = functions(\n      this,\n      isObject,\n      toNumber,\n      getType,\n      isArrayType,\n      getValueOf,\n      toString,\n      debug,\n    );\n\n    Object.entries(customFunctions).forEach(([fname, func]) => {\n      // Provide the runtime to custom functions so that\n      // they can implement lambda functions\n      // eslint-disable-next-line no-param-reassign\n      func._runtime = this;\n      this.functionTable[fname] = func;\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _validateArgs(argName, args, signature, bResolved) {\n    // Validating the args requires validating\n    // the correct arity and the correct type of each arg.\n    // If the last argument is declared as variadic, then we need\n    // a minimum number of args to be required.  Otherwise it has to\n    // be an exact amount.\n    if (signature.length === 0 && args.length > 0) {\n      throw functionError(`${argName}() does not accept parameters`);\n    }\n\n    if (signature.length === 0) {\n      return;\n    }\n    let pluralized;\n    const argsNeeded = signature.filter(arg => !arg.optional).length;\n    const lastArg = signature[signature.length - 1];\n    if (lastArg.variadic) {\n      if (args.length < signature.length) {\n        pluralized = signature.length === 1 ? ' argument' : ' arguments';\n        throw functionError(`${argName}() takes at least ${signature.length}${pluralized\n        } but received ${args.length}`);\n      }\n    } else if (args.length < argsNeeded || args.length > signature.length) {\n      pluralized = signature.length === 1 ? ' argument' : ' arguments';\n      throw functionError(`${argName}() takes ${signature.length}${pluralized\n      } but received ${args.length}`);\n    }\n    // if the arguments are unresolved, there's no point in validating types\n    if (!bResolved) return;\n    let currentSpec;\n    const limit = signature[signature.length - 1].variadic ? args.length\n      : Math.min(signature.length, args.length);\n\n    for (let i = 0; i < limit; i += 1) {\n      currentSpec = i > signature.length - 1 ? signature[signature.length - 1].types\n        : signature[i].types;\n      // eslint-disable-next-line no-param-reassign\n      args[i] = matchType(currentSpec, args[i], argName, this.toNumber, toString);\n    }\n  }\n\n  callFunction(name, resolvedArgs, data, interpreter, bResolved = true) {\n    // this check will weed out 'valueOf', 'toString' etc\n    if (!Object.prototype.hasOwnProperty.call(this.functionTable, name)) {\n      throw functionError(`No such function: ${name}()`);\n    }\n\n    const functionEntry = this.functionTable[name];\n    this._validateArgs(name, resolvedArgs, functionEntry._signature, bResolved);\n    return functionEntry._func.call(this, resolvedArgs, data, interpreter);\n  }\n}\n\nexport default class Formula {\n  constructor(debug, customFunctions, stringToNumberFn) {\n    this.debug = debug;\n    this.toNumber = getToNumber(stringToNumberFn || defaultStringToNumber);\n    this.runtime = new Runtime(debug, this.toNumber, customFunctions);\n  }\n\n  compile(stream, allowedGlobalNames = []) {\n    const parser = new Parser(allowedGlobalNames);\n    return parser.parse(stream, this.debug);\n  }\n\n  search(node, data, globals = {}, language = 'en-US') {\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    this.runtime.interpreter = new TreeInterpreter(\n      this.runtime,\n      globals,\n      this.toNumber,\n      toString,\n      this.debug,\n      language,\n    );\n\n    try {\n      return this.runtime.interpreter.search(node, data);\n    } catch (e) {\n      this.debug.push(e.message || e.toString());\n      if (e.name === 'Error') throw evaluationError(e.message || e.toString());\n      throw e;\n    }\n  }\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport Formula from './interpreter.js';\n\n/**\n * Class represents an instance of a JsonFormula Expression that can be executed later on with\n * multiple instances of JSON Data. The instance of the class has a search\n * function that can be used to evaluate the expression on a json payload.\n */\nclass JsonFormula {\n  /**\n   * @param {object} [customFunctions={}] custom functions needed by a hosting application.\n   * @param {function} [stringToNumber='null'] A function that converts string values to numbers.\n   * Can be used to convert currencies/dates to numbers\n   * @param {string} [language=en-US]\n   * @param {array} [debug=[]]  will be populated with any errors/warnings\n   */\n  constructor(\n    customFunctions = {},\n    stringToNumber = null,\n    debug = [],\n  ) {\n    this.customFunctions = { ...customFunctions };\n    this.stringToNumber = stringToNumber;\n    this.debug = debug;\n    this.formula = new Formula(debug, customFunctions, stringToNumber);\n  }\n\n  /**\n   * Evaluates the JsonFormula on a particular json payload and return the result\n   * @param {object|array} json the json data on which the expression needs to be evaluated\n   * @param {object} [globals={}] global objects that can be accessed via custom functions.\n   * @returns {*} the result of the expression being evaluated\n   */\n  search(expression, json, globals = {}, language = 'en-US') {\n    const ast = this.compile(expression, Object.keys(globals));\n    return this.run(ast, json, language, globals);\n  }\n\n  /**\n   * Execute a previously compiled expression against a json object and return the result\n   * @param {object} ast The abstract syntax tree returned from compile()\n   * @param {object|array} json the json data on which the expression needs to be evaluated\n   * @param globals {*} set of objects available in global scope\n   * @returns {*} the result of the expression being evaluated\n   */\n  run(ast, json, language, globals) {\n    return this.formula.search(\n      ast,\n      json,\n      globals,\n      language,\n    );\n  }\n\n  /**\n   * Creates a compiled expression that can be executed later on with some data.\n   * @param {string} expression the expression to evaluate\n   * @param {string[]} [allowedGlobalNames=[]] A list of names of the global variables\n   * being used in the expression.\n   * @param {array} [debug=[]] will be populated with any errors/warnings\n   */\n  compile(expression, allowedGlobalNames = []) {\n    this.debug.length = 0;\n    return this.formula.compile(expression, allowedGlobalNames);\n  }\n}\n\n/**\n * Compile and execute a json-formula expression.\n * If executing the same expression multiple times, it is more efficient to create a\n * class instance of {JsonFormula} and call the search method multiple times.\n* @param {object|array} json the json data on which the expression needs to be evaluated\n* @param {object} globals  global objects that can be accessed via custom functions.\n* @param {string} expression the expression to evaluate\n* @param {object} [customFunctions={}] custom functions needed by a hosting application.\n* @param {function} [stringToNumber='null'] A function that converts string values to numbers.\n* Can be used to convert currencies/dates to numbers\n* @param {string} [language=en-US]\n* @param  {array} [debug=[]] will be populated with any errors/warnings\n* @returns {*} the result of the expression being evaluated\n */\n\nexport function jsonFormula(\n  json,\n  globals,\n  expression,\n  customFunctions = {},\n  stringToNumber = null,\n  debug = [],\n  language = 'en-US',\n) {\n  return new JsonFormula(customFunctions, stringToNumber, debug)\n    .search(expression, json, globals, language);\n}\n\nexport default JsonFormula;\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n/*\n    Field class allows objects to evaluate correctly according to context.\n    - if used in an expression, will return a value or string.\n    - for JSON.stringify() returns a scalar\n    - BUT also allows explicit access to properties. e.g. field.required, field.name etc.\n\n    Should allow us to eliminate getFieldProperty()\n  */\nclass ArrayClass extends Array {}\nclass ObjectClass {}\n\nfunction createField(name, value, readonly = false, required = true) {\n  class Field extends ObjectClass {\n    valueOf() { return value; }\n\n    toString() { return value.toString(); }\n\n    toJSON() { return value; }\n  }\n  const f = new Field();\n  Object.defineProperty(f, '$name', { get: () => name });\n  Object.defineProperty(f, '$value', { get: () => value });\n  Object.defineProperty(f, '$readonly', { get: () => readonly });\n  Object.defineProperty(f, '$required', { get: () => required });\n\n  return f;\n}\n\nfunction createFieldset(fsname, isObj, fields, children) {\n  class FieldsetObj extends ObjectClass {\n    _add(k, v) {\n      this[k] = v;\n      children.push(v);\n    }\n  }\n  class FieldsetArray extends ArrayClass {\n    _add(k, v) {\n      this[k] = v;\n      children.push(v);\n    }\n  }\n  const fieldset = isObj ? new FieldsetObj() : new FieldsetArray();\n  Object.defineProperty(fieldset, '$name', { get: () => fsname });\n  Object.defineProperty(fieldset, '$fields', { get: () => fields });\n  Object.defineProperty(fieldset, '$value', { get: () => fieldset.valueOf() });\n\n  return fieldset;\n}\n\nfunction createFields(parent, childref, child) {\n  const result = [];\n  if (child instanceof Array) {\n    // parent._add(childref, createFieldset(childref, false));\n    parent._add(childref, createFieldset(childref, false, result, []));\n    child.forEach((item, index) => {\n      const fields = createFields(parent[childref], index, item);\n      result.push(...fields);\n    });\n  } else if (child !== null && typeof child === 'object') {\n    parent._add(childref, createFieldset(childref, true, result, []));\n    Object.keys(child).forEach(k => {\n      const fields = createFields(parent[childref], k, child[k]);\n      result.push(...fields);\n    });\n  } else {\n    const field = createField(childref, child);\n    parent._add(childref, field);\n    result.push(field);\n  }\n  return result;\n}\n\nexport default function createForm(dataRoot) {\n  // if it's not an object or array (a scalar) then don't bother trying to create a form\n  if (dataRoot === null || typeof dataRoot !== 'object') return dataRoot;\n\n  const allFields = [];\n  const form = createFieldset('', !Array.isArray(dataRoot), allFields, []);\n  Object.entries(dataRoot).forEach(([k, v]) => {\n    allFields.push(...createFields(form, k, v));\n  });\n  return form;\n}\n","/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nimport { typeError } from './errors.js';\n\nexport default function stringToNumber(n) {\n  const ret = +n;\n  if (Number.isNaN(ret)) {\n    throw typeError(`Failed to convert \"${n}\" to number`);\n  }\n  return ret;\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* global window, document */\nimport Formula from '../src/json-formula.js';\nimport createForm from './Form.js';\nimport stringToNumber from '../src/stringToNumber.js';\n\nwindow.addEventListener('load', () => {\n  const dataElement = document.getElementById('data');\n  const expression = document.getElementById('expression');\n  const result = document.getElementById('result');\n  const debug = document.getElementById('debug');\n  const debugInfo = [];\n  // keep one instance active for the entire session so that any registered\n  // functions are retained\n  const formula = new Formula({}, stringToNumber, debugInfo);\n  const defaultData = `{\n    \"address\": {\n      \"street\": \"12 Oak St\",\n      \"city\": \"San Jose\",\n      \"state\": \"CA\",\n      \"country\": \"USA\",\n      \"phone\": \"1234561234\"\n    },\n    \"items\": [\n      {\n        \"desc\": \"pens\",\n        \"quantity\": 2,\n        \"price\": 3.23\n      },\n      {\n        \"desc\": \"pencils\",\n        \"quantity\": 3,\n        \"price\": 1.34\n      }\n    ],\n    \"tax\": 1.13\n  }`;\n\n  const params = new URLSearchParams(document.location.search);\n  if (params.has('sample')) {\n    const sampleJSON = JSON.parse(atob(params.get('sample')));\n    if (sampleJSON.data) dataElement.value = JSON.stringify(sampleJSON.data, null, 2);\n    if (sampleJSON.expression) expression.value = sampleJSON.expression;\n    if (sampleJSON.description) {\n      document.getElementById('description-row').style.display = 'table-row';\n      document.getElementById('description').innerText = sampleJSON.description;\n    }\n    Array.from(document.getElementsByClassName('controls')).forEach(c => c.classList.add('hidden'));\n  } else {\n    const d = window.localStorage.getItem('data');\n    if (d) dataElement.value = d;\n    else dataElement.value = defaultData;\n    const exp = window.localStorage.getItem('expression');\n    if (exp) expression.value = exp;\n    else expression.value = 'sum(items[*].price * items[*].quantity)';\n  }\n\n  function run() {\n    // save for next time...\n    window.localStorage.setItem('data', dataElement.value);\n    window.localStorage.setItem('expression', expression.value);\n    const input = expression.value;\n    const useFields = document.getElementById('use-fields').checked;\n    let jsonData;\n    try {\n      jsonData = JSON.parse(dataElement.value);\n      if (useFields) {\n        jsonData = createForm(jsonData);\n      }\n    } catch (e) {\n      result.value = e.toString();\n      return;\n    }\n\n    try {\n      const jsonResult = formula.search(input, jsonData, {});\n      debug.innerHTML = debugInfo.join('\\n');\n      let r = jsonResult;\n      if (jsonResult !== null && jsonResult !== undefined) {\n        r = jsonResult.valueOf.call(jsonResult);\n      }\n      if (typeof r === 'object') {\n        result.value = JSON.stringify(r, null, 2);\n      } else {\n        result.value = r;\n      }\n    } catch (e) {\n      result.value = e.toString();\n      debug.innerHTML = debugInfo.join('\\n');\n    }\n  }\n\n  dataElement.addEventListener('blur', run);\n  expression.addEventListener('blur', run);\n  document.getElementById('data-reset').addEventListener(\n    'click',\n    () => {\n      dataElement.value = defaultData;\n      if (params.has('sample')) {\n        expression.value = 'sum(items[*].price * items[*].quantity)';\n        document.getElementById('description-row').style.display = 'none';\n        Array.from(document.getElementsByClassName('controls')).forEach(c => c.classList.remove('hidden'));\n        window.history.pushState({}, document.title, '/');\n        run();\n      }\n    },\n  );\n  document.getElementById('canned').addEventListener('change', e => {\n    expression.value = e.target.value;\n    run();\n  });\n  run();\n\n  fetch('../antlr/JsonFormula.g4').then(r => {\n    r.text().then(g4 => {\n      // remove comments and processing directives.\n      const strippedGrammar = g4\n        .replace(/[\\s\\S.]*grammar/m, 'grammar')\n        .replace(/#.*/g, '');\n      document.getElementById('grammar-out').innerHTML = strippedGrammar;\n    });\n  });\n});\n"],"names":["__webpack_require__","exports","Symbol","toStringTag","Object","defineProperty","value","dataTypes","TYPE_NUMBER","TYPE_ANY","TYPE_STRING","TYPE_ARRAY","TYPE_OBJECT","TYPE_BOOLEAN","TYPE_EXPREF","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TYPE_ARRAY_ARRAY","TYPE_EMPTY_ARRAY","typeNameTable","TOK_EOF","TOK_IDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_CONCATENATE","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_GLOBAL","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_ADD","TOK_SUBTRACT","TOK_UNARY_MINUS","TOK_MULTIPLY","TOK_UNION","TOK_DIVIDE","TOK_COMPARATOR","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_NOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_JSON","TOK_STRING","TOK_INT","typeError","desc","TypeError","syntaxError","e","Error","name","functionError","evaluationError","tokenDefinitions","isArray","t","includes","getType","inputObj","obj","JSON","parse","stringify","prototype","toString","call","length","every","a","jmespathType","isArrayType","getTypeName","arg","matchType","expectedList","argValue","context","toNumber","actual","isObject","some","type","match","expect","found","exactMatch","expected","wrongType","map","join","keys","toArray","Array","getValueOf","i","valueOf","toBoolean","param","val","strictDeepEqual","lhs","rhs","first","second","f","key","hasOwnProperty","getProperty","getOwnPropertyDescriptor","enumerable","get","for","debugAvailable","debug","push","available","entries","getOwnPropertyDescriptors","filter","k","test","startsWith","balanceArrayOperands","opLeft","opRight","shorter","diff","Math","abs","fill","TreeInterpreter","constructor","runtime","globals","language","this","search","node","visit","field","undefined","n","v","visitFunctions","Identifier","bind","QuotedIdentifier","ChainedExpression","result","children","BracketExpression","left","Index","index","Slice","sliceParams","start","stop","step","computeSliceParams","Projection","base","collected","forEach","b","current","ValueProjection","projection","values","FilterProjection","filtered","finalResults","Comparator","type1","type2","_e","original","merged","Identity","_node","ArrayExpression","child","ObjectExpression","OrExpression","matched","AndExpression","AddExpression","applyOperator","ConcatenateExpression","UnionExpression","concat","SubtractExpression","MultiplyExpression","DivideExpression","NotExpression","UnaryMinusExpression","minus","Number","isNaN","String","Literal","Integer","Function","callFunction","resolvedArgs","ExpressionReference","refNode","arrayLength","capSliceRange","arrayLen","stp","actualValue","stepValueNegative","operator","n1","n2","isFinite","basicTokens","operatorStartToken","skipChars","isAlphaNum","ch","isIdentifier","stream","pos","Lexer","allowedGlobalNames","_allowedGlobalNames","tokenize","tokens","identifier","token","_current","prev","slice","_isGlobal","_consumeGlobal","_consumeUnquotedIdentifier","_isNumber","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","json","_consumeJson","_consumeOperator","_consumeUnaryMinus","maxLength","foundNonAlpha","replace","substring","literal","num","toLowerCase","parseFloat","parseInt","global","startingChar","literalString","trimStart","replaceAll","bindingPower","Parser","expression","_loadTokens","ast","_lookahead","_lookaheadToken","rbp","leftToken","_advance","nud","currentToken","led","number","previous","next","_lookAheadIndex","idx","_getIndex","_setIndex","right","args","Not","UnaryMinus","_parseProjectionRHS","Star","_parseObjectExpression","Flatten","_parseIndexExpression","_projectIfSlice","_parseArrayExpression","Expref","_match","_errorToken","condition","leftNode","rightNode","Concatenate","Dot","_parseDotRHS","Pipe","Or","And","Add","Subtract","Multiply","Divide","Union","_parseFunctionArgs","Filter","_parseComparator","tokenType","firstExpression","_parseSignedInt","oldIndex","_parseSliceExpression","indexExpr","parts","comparator","lookahead","indexOf","expressions","pairs","identifierTypes","keyToken","keyName","MS_IN_DAY","getDateObj","dateNum","Date","round","getDateNum","dateObj","validNumber","defaultStringToNumber","str","Runtime","customFunctions","functionTable","toInteger","trunc","toJSON","indent","offset","functionMap","_func","_signature","types","acos","and","variadic","asin","atan2","avg","sum","inputArray","casefold","_data","interpreter","toLocaleUpperCase","toLocaleLowerCase","ceil","codePoint","text","codePointAt","contains","subject","s","source","from","searchLen","cos","datedif","unit","date1","date2","floor","yearDiff","getFullYear","monthDiff","getMonth","dayDiff","getDate","y","setFullYear","datetime","year","month","day","hours","minutes","seconds","ms","optional","deepScan","checkArrays","items","scan","endsWith","searchStr","suffix","reverse","c","eomonth","jsDate","months","exp","false","find","query","j","fromCodePoint","code","fromEntries","array","fround","hasProperty","keyType","hour","getHours","if","unresolvedArgs","data","conditionNode","leftBranchNode","rightBranchNode","listJoin","joinChar","numEntries","log","log10","lower","exprefNode","max","reduce","cur","sort","pop","merge","mid","startPos","millisecond","getMilliseconds","min","minute","getMinutes","mod","p1","p2","not","resolveArgs","notNull","now","null","or","power","proper","capitalize","word","charAt","toUpperCase","wordParts","w","random","accumulated","register","functionName","_exprefNode","numElements","sourceArray","replacement","splice","newText","rept","count","repeat","originalStr","digits","precision","findText","withinText","globString","acc","escape","testMatch","glob","testChar","globChar","nextGlob","isStar","within","getSeconds","sign","sin","sortBy","sortedArray","requiredType","decorated","exprA","typeA","exprB","typeB","split","separator","sqrt","prefix","stdev","mean","sumSquare","stdevp","meanSumSquare","substitute","src","old","whch","tan","time","toDate","iso","dateparts","d","x","range","getTime","today","digitCheck","decimal","trim","true","unique","valueArray","findIndex","lookup","upper","indexType","subjectArray","weekday","date","getDay","zip","functions","fname","func","_runtime","_validateArgs","argName","signature","bResolved","pluralized","argsNeeded","currentSpec","limit","functionEntry","Formula","stringToNumberFn","stringToNumber","getToNumber","compile","message","formula","run","ArrayClass","ObjectClass","createFieldset","fsname","isObj","fields","fieldset","_add","createFields","parent","childref","item","readonly","required","createField","ret","window","addEventListener","dataElement","document","getElementById","debugInfo","defaultData","params","URLSearchParams","location","has","sampleJSON","atob","description","style","display","innerText","getElementsByClassName","classList","add","localStorage","getItem","setItem","input","useFields","checked","jsonData","dataRoot","allFields","form","createForm","jsonResult","innerHTML","r","remove","history","pushState","title","target","fetch","then","g4","strippedGrammar"],"sourceRoot":""}